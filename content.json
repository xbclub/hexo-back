{"meta":{"title":"42cloud and 42team","subtitle":null,"description":"这是一个有趣的空间","author":"42team","url":"http://123.56.84.132/public"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-02-14T09:11:23.000Z","comments":false,"path":"about/index.html","permalink":"http://123.56.84.132/public/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-14T09:11:23.000Z","comments":false,"path":"bangumi/index.html","permalink":"http://123.56.84.132/public/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-02-14T09:11:23.000Z","comments":false,"path":"client/index.html","permalink":"http://123.56.84.132/public/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-14T09:11:23.000Z","comments":true,"path":"comment/index.html","permalink":"http://123.56.84.132/public/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-02-14T09:11:23.000Z","comments":false,"path":"donate/index.html","permalink":"http://123.56.84.132/public/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-14T09:11:23.000Z","comments":false,"path":"lab/index.html","permalink":"http://123.56.84.132/public/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-14T09:11:23.000Z","comments":true,"path":"links/index.html","permalink":"http://123.56.84.132/public/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-14T09:11:23.000Z","comments":false,"path":"music/index.html","permalink":"http://123.56.84.132/public/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-02-14T09:11:23.000Z","comments":true,"path":"rss/index.html","permalink":"http://123.56.84.132/public/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-02-14T09:11:23.000Z","comments":true,"path":"tags/index.html","permalink":"http://123.56.84.132/public/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-02-14T09:11:23.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://123.56.84.132/public/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-02-14T09:11:23.000Z","comments":false,"path":"video/index.html","permalink":"http://123.56.84.132/public/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"C++指针与引用(包含智能指针)","slug":"2","date":"2020-03-04T09:17:16.000Z","updated":"2020-03-06T08:48:17.512Z","comments":true,"path":"2020/03/04/2/","link":"","permalink":"http://123.56.84.132/public/2020/03/04/2/","excerpt":"","text":"指针指针是特殊的变量,指向内存中的地址(地址类型与操作系统内部实现相关) 指针类型从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。 this 指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。 返回*this指针作为左值返回,const函数返回常量指针 在以下场景中，经常需要显式引用this指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 智能指针将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。 智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放， 智能指针就是一种栈上创建的对象，函数退出时会调用其析构函数，这个析构函数里面往往就是一堆计数之类的条件判断，如果达到某个条件，就把真正指针指向的空间给释放了。 shared_ptr多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 weak_ptrweak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 unique_ptrunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 用于取代 auto_ptr auto_ptr被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。 auto_ptr 与 unique_ptr 比较 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）； 不要混合使用普通指针和智能指针 无法知道对象何时被销毁,容易造成空悬指针 不要使用get初始化另外一个智能指针或为智能指针赋值 get函数返回一个内置指针,用来将指针的访问权限传递给代码,明确代码不使用delete时才能用get,永远不要用get初始化一个智能指针或者为一个智能指针赋值 引用引用为变量的别名，底层实现仍为指针． 指针和引用 1.指针为间接访问,引用为直接访问 2.引用为变量的别名,不占据内存空间,指针有自己的内存 3.引用绑定内存空间必须赋值,一个变量的别名不能更改绑定,可以改变对象的值 4.引用只有一级，而指针可以有多级 5.指针传参的时候，还是值传递，指针本身的值不可以修改，需要通过解引用才能对指向的对象进行操作，引用传参的时候，传进来的就是变量本身，因此变量可以被修改","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"C++","slug":"代码学习/C","permalink":"http://123.56.84.132/public/categories/代码学习/C/"}],"tags":[],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"C++","slug":"代码学习/C","permalink":"http://123.56.84.132/public/categories/代码学习/C/"}]},{"title":"（九） python 高级特性","slug":"13","date":"2020-02-22T11:42:27.000Z","updated":"2020-03-06T05:38:55.296Z","comments":false,"path":"2020/02/22/13/","link":"","permalink":"http://123.56.84.132/public/2020/02/22/13/","excerpt":"","text":"在python中，我们所拥有以下几种非常有用的高级特性能够使我们在编写代码的过程中，使我们的代码量大大减少。 - 切片（Slice）切片常用于从某个对象中抽取部分值的情况，只要条件表达式得当，可以通过单次或多次切片操作实现任意目标值的切取。 如果你想尽快知道list(range(1,21))实现原理，可以先观看本章的列表生成器部分。 L = list(range(1,21)) #自定义一个列表，存入有序数列1-20共二十个数 print(L) #打印列表L print(type(L)) #打印列表类型 print(L[0:5]) #打印列表前五个值即下标为0-4，[0:5]表示从索引0开始，直到索引5结束，但不包括索引3 print(L[:5]) #与上条功能相同，表达式更简便 print(L[17:20]) #打印列表最后三位数字即下标为17，18，19的三位数。[17:20]表示从索引17开始，直到索引20结束，但不包括索引20。 print(L[-3:]) #与上条功能相同，表达式更简便 print(L[:10:5]) #列表的前十个数中，每五个数取一个值 print(L[::5]) #列表的所有数中，每五个数从中取一个 打印为： [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] &lt;class &#39;list&#39;&gt; [1, 2, 3, 4, 5] [1, 2, 3, 4, 5] [18, 19, 20] [18, 19, 20] [1, 6] [1, 6, 11, 16] tuple也是list的一种，区别是tuple不可变，所以tuple也是可以使用切片操作，不过结果仍是tuple。字符串‘ XXX ‘也可以看成一种list,不过每一个字符就是一个元素，所以字符串也是可以使用切片操作，不过结果仍是字符串。 T = (1,2,3,4,5,6,7,8,9,10) #创建一个tuple print(T) #打印tuple print(T[:]) #[:]效果与本身相同 print(T[:3]) #打印tuple前三个值 print(type(T[:])) #打印tuple切片后获取到的数据的数据类型 S = &quot;Python&quot; #创建一个字符串 print(S[:3]) #切片获取前三个值，即组合成的新的字符串 print(type(S[:])) #获取字符串切片后的数据的数据类型 打印为： (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) (1, 2, 3) &lt;class &#39;tuple&#39;&gt; Pyt &lt;class &#39;str&#39;&gt; - 迭代（Iteration）如果给定一个list或tuple等，我们可以通过for循环进行遍历，这种遍历我们叫做迭代。在Python中迭代是通过for...in...来完成的。 我们判断一个对象是不是迭代对象可以引用 collections.abc 模板下的Iterable。例如： #导入 from collections.abc import Iterable L = list(range(5)) #创建数组 print(isinstance(L,Iterable)) #判断数组 L 是否是可迭代对象并打印出来 print(isinstance(&#39;abc&#39;,Iterable)) #判断 字符串&#39;abc&#39; 是否是可迭代对象并打印出来 # 遍历数组L，并打印 for value in L: print(value) 打印为： True True 0 1 2 3 4 对于dict我们也可以进行迭代，但由于键值对我们默认只迭代key，如果想要迭代value我们可以使用dict.values(),如果想要同时迭代key和value我们则需要使用dict.items()。 d = {&quot;Join&quot;: &quot;蛋糕&quot;, &quot;Tom&quot;: &quot;雪糕&quot;} #创建dict print(&quot;-----只迭代key-----&quot;) for key in d: print(key) print(&quot;-----只迭代value-----&quot;) for value in d.values(): print(value) print(&quot;-----同时迭代key和value-----&quot;) for k,v in d.items(): print(&quot;key : &quot; + k , &quot;\\tvalue:&quot; , v) 打印结果为： -----只迭代key----- Join Tom -----只迭代value----- 蛋糕 雪糕 -----同时迭代key和value----- key : Join value: 蛋糕 key : Tom value: 雪糕 像我们刚刚迭代dict，能够同时获取两个值，其实，元素对返回的是一个元组数据，所以可以我们拆分成多个变量去接，方便我们同时引用多个变量。 for x, y in [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]: print(&#39;x =&#39;, x, &#39;y =&#39;, y) 打印为： x = 1 y = a x = 2 y = b x = 3 y = c 如果我们想要获取到迭代对象的下标，我们可以使用Python内置的enumerate函数把它变成索引-元素对，这样我们就可以同时迭代索引和元素对本身。 #迭代dict，默认只迭代key值 for i, key in enumerate({&quot;Join&quot;: &quot;蛋糕&quot;, &quot;Tom&quot;: &quot;雪糕&quot;}): print(&#39;i =&#39;, i, &#39;key =&#39;, key) 打印为： i = 0 key = Join i = 1 key = Tom - 列表生成式列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 例如： L1 = list(range(1,10)) L2 = list(range(0,10)) L3 = list(range(10)) #等同第二个 print(L1) print(L2) print(L3) 打印为： [1, 2, 3, 4, 5, 6, 7, 8, 9] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 当然列表生成器还有更多略微复杂的操作，如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环，方法二则是我们使用列表生成器代替循环，例如： L1 = [] # 方法一：使用for循环，每次循环都在列表结尾进行追加 for x in range(1,11): L1.append(x * x) #方法二：列表生成器 L2 = [a * a for a in range(1,11)] print(L1) print(L2) 打印为： [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 我们甚至可以进行更多操作： # 创建成功列表后在判断进行取出源列表内的所有偶数集 L1 = [x * x for x in range(1,11) if x % 2 == 0] #有if那么我们肯定就有else语句 L2 = [x * x if x % 2 == 0 else 0 for x in range(1,11)] #从第一个字符串中挨个取出作为x,从第二个字符串中挨个取出作为y，并进行组合排列 L3 = [x + y for x in &#39;唱跳R&#39; for y in &#39;吃喝玩&#39;] #把list中的所有字符串都变成小写 L4 = [&#39;Boy&#39;,&#39;Girl&#39;,&#39;IBM&#39;] L4 = [s.lower() for s in L4] print(L1) print(L2) print(L3) print(L4) 打印为： [4, 16, 36, 64, 100] [0, 4, 0, 16, 0, 36, 0, 64, 0, 100] [&#39;唱吃&#39;, &#39;唱喝&#39;, &#39;唱玩&#39;, &#39;跳吃&#39;, &#39;跳喝&#39;, &#39;跳玩&#39;, &#39;R吃&#39;, &#39;R喝&#39;, &#39;R玩&#39;] [&#39;boy&#39;, &#39;girl&#39;, &#39;ibm&#39;] - 生成器 什么是生成器 在Python中，一边循环一边计算的机制，称为生成器：generator。并且生成器仅仅保存了一套生成数值的算法，并且没有让这个算法现在就开始执行，而是我什么时候调它，它什么时候开始计算一个新的值， 为什么要有生成器 如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。如果我们想要得到庞大的数据，又想让它占用空间少，那我们最好的方法就是使用生成器。 并给你返回。 我们创建一个generator只需要把列表生成式的[]改为（）就可以。 g = (x for x in range(1,11)) #创建一个generator print(g) #打印 print(type(g)) #打印其类型 print(&quot;-----使用next()获取generator的每一个值-----&quot;) #打印g的元素,next()只可以返回获得generator的下一个返回值，所以我们如果一直使用next()函数获取generator的每一个值会非常麻烦也不现实 print(next(g)) print(next(g)) print(next(g)) print(&quot;------使用for循环获取generator的每一个值-----&quot;) for i in g: print(i) 打印结果为: &lt;generator object &lt;genexpr&gt; at 0x10fd64750&gt; &lt;class &#39;generator&#39;&gt; -----使用next()获取generator的每一个值----- 1 2 3 ------使用for循环获取generator的每一个值----- 4 5 6 7 8 9 10 如果算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return &#39;done&#39; f = fib(5) print(f) 打印为： &lt;generator object fib at 0x10353a750&gt; 如果一个函数中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行 - 迭代器 生成器都是迭代器，而基本数据集合不属于迭代器，区别在于能不能使用next(), 可以用iter([])来讲基本集合类型转化为迭代器 迭代器对象无法预知集合的长度，是一个在调用的时候才能获取到对应位置对象的惰性计算对象，是一种流的形式 Python的for循环本质上就是通过不断调用next()函数实现的， Iterable 迭代类型 Iterator 迭代器","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"python","slug":"python","permalink":"http://123.56.84.132/public/tags/python/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"（八）python 函数（下）","slug":"18","date":"2020-02-20T04:27:00.000Z","updated":"2020-03-06T05:38:55.404Z","comments":false,"path":"2020/02/20/18/","link":"","permalink":"http://123.56.84.132/public/2020/02/20/18/","excerpt":"","text":"在定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。 函数参数-位置参数位置参数是调用函数时根据函数定义的参数位置来传递参数，也就是说调用函数时传入实际参数的数量与位置都必须和原函数定义时保持一致 实参和形参数量位置必须都保持一致 # 定义函数名称为perometer 定义参数 长long 宽width 冒号结尾 def perometer(long,width): # 用户输入通过input()函数我们所获取到的值默认为str类型，我们不能够进行比较大小，所以需要进行转换成int类型 # 若长方形的长小于宽，则会打印提示我们调用函数时是两个参数顺序错误而导致 if int(long) &lt; int(width): print(&quot;长方形的长宽不符合规范&quot;) pass return 2 * ( int(long) + int(width) ) # 获取用户输入的长，值的名称定义为x x = input(&quot;请输入一个长 ： &quot;) # 获取用户输入的宽，值的名称定义为y y = input(&quot;请输入一个宽 ： &quot;) # perometer（）函数返回的值为int类型无法与字符串进行拼接，所以需要把它在进行强转为str类型 print(&quot;该长方形的周长为 ： &quot;+ str(perometer(x,y))) -默认参数perometer()函数我们定义已经没有问题，但当我们如果要去求多个不同长却同宽为1的周长时，我们可使用以下方式 def perometer(long,width = 1): if int(long) &lt; int(width): print(&quot;长方形的长宽不符合规范&quot;) pass return 2 * ( int(long) + int(width) ) print(&quot;该长方形的周长为 ： &quot;+ str(perometer(10))) 我们可设置长方形的宽默认为1。这样在我们调用perometer(10)的时候就相当于调用perometer(10,1)了 但是我们一定要注意，必选参数在前，默认参数在后，否则Python解释器会报错。默认参数也必须指向不变对象。 - 可变参数在Python函数中，我们可以进行定义可变参数，其含义就是我们传入的参数的个数是可变的，可以使1个、2个、多个或无参。 # 定义函数add() 参数为可变参数nums #函数内参数nums接收到的是一个tuple，会自动转换成tuple def add(*nums): sum = 0 # 遍历nums， for i in nums: sum = sum + i return sum # add()为可变参数则我们就不需要传入list或tuple在进行遍历，直接简化输入多个参或无参即可 print(add(1,2,3)) -关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。 def animals(name, age, **kw): print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw) animals(&#39;Boby&#39;,1) animals(&#39;Mini&#39;, 6, city=&#39;Beijing&#39;) extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;} animals(&#39;Lili&#39;, 8, city=extra[&#39;city&#39;], job=extra[&#39;job&#39;]) 打印为： name: Boby age: 1 other: {} name: Mini age: 6 other: {&#39;city&#39;: &#39;Beijing&#39;} name: Lili age: 8 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;} 有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序的。","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"python","slug":"python","permalink":"http://123.56.84.132/public/tags/python/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"(七) python 函数(上)","slug":"3","date":"2020-02-19T09:07:49.000Z","updated":"2020-03-06T05:38:55.764Z","comments":false,"path":"2020/02/19/3/","link":"","permalink":"http://123.56.84.132/public/2020/02/19/3/","excerpt":"","text":"什么是函数 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码块 我们为什么要用函数 函数能够提高应用的模块性，和代码的重复利用率，我们在前面章节里已经使用了很多内置函数，比如print()、len()、max()、input()等。可以直接从Python官方网站查看文档点这里。但我们也可以自建函数，我们叫做用户自定义函数。 内置函数当我们在调用内置函数的同时，也要保证传入参数的数量与类型是正确的。 #如果函数内传入的参数数量不对会报TypeError错误。并明确指出函数的参数规则要求 # 判断数字1和6谁的值最大并打印出来 print(max(1,6)) #6 # 获取数字-20的绝对值并打印出来 print(abs(-20)) #20 # 获取字符串 &quot;42team&quot; 的长度并打印出来 print(len(&quot;42team&quot;)) #6 #将字符串类型的数字转换成int类型，如果使用ty()函数查看int(&#39;1234&#39;)会发现其类型已经不再是str而是int print(int(&#39;1234&#39;)) #1234 当我们对一个新的内置函数并不了解其含义时，不仅可以访问官方文档，还可以使用内置函数help()去查看相关函数的帮助信息。 print(help(len)) 定义函数 我们可-以随意自定义一个由自己想要功能的函数，简单规则如下： 函数代码必须以def关键字开头，后接函数标识符名称和圆括号() 任何传入参数与自变量必须都要放在圆括号中间，圆括号中可以用于定义参数。 函数内容以冒号起始，并且缩进。 return [表达式]用来结束函数，返回一个值给调用方。不带表达式的return相当于返回None 例如我们自定义一个myMax()函数用来实现获取两个值的最大值： #def关键词 函数名称为myMax 圆括号内为可传进来的两个参数 冒号结尾 def myMax(a,b): # 判断传入参数a与传入参数b的数据类型是否均为int类型 if type(a) == int and type(b) == int : # 如果a大于或等于b，则输出a，否则输出b if a &gt;= b: return a else: return b else: return None # 传入参数-1与3，调用函数结束后并打印返回值 print(myMax(-1,3)) 函数内部语句在执行过程中，一旦执行到return，函数即执行完毕并返回结果值 如果你已将包含myMax()函数的文件保存为function.py文件，那么在该文件的同一级下的其他python文件内，也可使用from function import myMax 来导入myMax()函数 空函数如果想定义一个什么事也不做的空函数，可以使用pass语句： def notRun(): pass pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。因为很多语句都需要有返回语句，如果没有代码就会有语法错误，所以可以使用pass代替。 返回多个值有的时候我们需要通过一个函数获取多个值，这也是绝对可以实现的。 # 定义函数moreNum def moreNum(a,b): # 返回a与b进行加减乘除的四个值，不过结果集是一个元组（tuple） return a+b,a-b,a*b,a/b print(moreNum(12,2)) 打印为： (14, 10, 24, 6.0)","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"python","slug":"python","permalink":"http://123.56.84.132/public/tags/python/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"Github+jsDelivr+PicGo 打造高可用图床","slug":"20","date":"2020-02-16T05:58:26.000Z","updated":"2020-03-06T05:38:55.476Z","comments":false,"path":"2020/02/16/20/","link":"","permalink":"http://123.56.84.132/public/2020/02/16/20/","excerpt":"","text":"为什么使用Github+jsDelivr+PicGo做为图床 什么是jsDelivr jsDelivr 能够集成 Github、NPM 资源，只需要通过符合 jsDelivr 规则的 URL 引用，即可直接使用 Github 中的资源。也可以使用发布到 NPM 的资源，这就是生产力。 什么是PicGo PicGo是一个用于图片上传的工具。支持CLI 和 api。 优势是什么 免费：数据存储在GitHub，所以存储空间免费，网络和技术由jsDelivr提供,jsDelivr 目前免费，PicGo是GitHub上的开源项目。 高速：jsDelivr使用CloudFlare作为CDN，CloudFlare目前在中国境内设有多个CDN节点，所以不用担心因地区导致的速度问题。 使用方法 创建仓库 创建仓库方法请查看本文：在？还没用Github? 生成Token 操作如图： 设置PicGo 操作如图： 设定仓库名：按照【用户名 / 图床仓库名】的格式填写 设定分支名：【master】 设定Token：粘贴之前生成的【Token】 指定存储路径：填写想要储存的路径，如【upload/】，这样就会在仓库下创建一个名为 upload 的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的作用是，在图片上传后，PicGo会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】，上传完毕后，我们就可以通过【https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径】加速访问我们的图片了，比如： https://cdn.jsdelivr.net/gh/xbclub/imageCDN//upload/d9136f8889a005564f6edcd4f1db471f.th.webp 开始使用PicGo 按照软件界面要求上传图片即可 然后将得到的链接粘贴到需要的位置即可。 Picgo插件 picgo-plugin-autocopy插件可以文件上传后直接复制到剪贴板下载点这里","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}]},{"title":"（五）运算符和表达式（下）","slug":"14","date":"2020-02-09T14:17:25.000Z","updated":"2020-03-06T05:38:55.312Z","comments":true,"path":"2020/02/09/14/","link":"","permalink":"http://123.56.84.132/public/2020/02/09/14/","excerpt":"","text":"今天要讲的内容 1、赋值运算 2、字符连接运算 3、条件（三目）运算 赋值运算“=”称为赋值运算符，用于对变量赋值。赋值表达式本身也有值，其本身之值即为所赋之值 1 int a,b,c; 2 a=b=c=100; 使用扩展赋值表达式： 运算符 表达式 计算 结果(假设X=10) += X+=5 X=X+5 15 -+ X-=5 X=X-5 5 *= X*=5 X=X*5 50 /= X/=5 X=X/5 2 %= X%=5 X=X%5 0 使用“+”进行字符连接： +可以实现字符串的连接，同时可以实现字符串与其他数据类型的“相连” int a=100; String msg=&quot;a=&quot;+a; System.out.println(msg); msg=&quot;&quot;+100+200; System.out.println(msg);//结果为：100200 msg=100+200+&quot;&quot;; System.out.println(msg);//结果为：300 注： 字符串拼接“+” +左右为数字时，做加法运算 +左右有一边为字符串（“”）时，做连接 使用条件（三目）运算符·条件运算符又称“三目”运算符，其结构为：boolean表达式？表达式1：表达式2 //三目/条件运算boolean ？1: 2 //运算过程： //1.计算boolean的值 //2.若为true，则整个的结果为1的值 // 若为false，则整个结果为2的值 int a=5,b=6; int max= a&gt;b ? a:b; System.out.println(max);//6 ·条件运算符规则如下： 运算过程： 1.计算boolean的值 2.若为true，则整个的结果为1的值 若为false，则整个结果为2的值 条件（三目）运算符的嵌套：·条件运算符可以嵌套使用，所谓嵌套是指在条件（三目）表达式：“boolean表达式?表达式1:表达式2”中的表达式1或表达式2也是条件（三目）表达式 //三目运算的嵌套 int a=-3; String r=a&gt;0?&quot;正数&quot;:(a==0?&quot;0&quot;:&quot;负数&quot;); System.out.println(r);","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://123.56.84.132/public/tags/java/"},{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}]},{"title":"（六） python条件判断与循环","slug":"25","date":"2020-02-08T23:05:09.000Z","updated":"2020-03-06T05:38:55.616Z","comments":true,"path":"2020/02/09/25/","link":"","permalink":"http://123.56.84.132/public/2020/02/09/25/","excerpt":"","text":"- if判断语句每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。if语句根据条件测试的值为True还是False来决定是否执行if语句中的代码。 在掌握了判断语句的使用规则外我们应该学会使用判断语句的流程，它主要分为以下几种： - 简单条件语句 - 多重条件语句 - 嵌套条件语句 在之前我们已经学习过Python的数据类型与相关知识，现在可以进行编写Python程序 1. 简单条件语句如果if所执行语句大于10，则执行可以执行if判断语句下的print()，else下的语句则会被系统自动忽略。 非字符串数据类型值若想与字符串进行拼接则需要进行类型转换 age = 20 if age &gt; 10: print(str(age) + &quot;大于10&quot;) else: print(str(age) + &quot;小于等于10&quot;) 并且python中的逻辑运算符还包括以下三种 or(逻辑或) not(逻辑非) and(逻辑与) a = 5 b = 20 if a &gt;= 10 or b &gt;=10: print(&quot;只要a或者b有一个值是大于等于10，才会执行这条语句&quot;) if not a &gt;= 10: print(&quot;只有a不大于等于10，才会执行这条语句&quot;) if a &gt;= 0 and b &gt;= 0: print(&quot;只有a和b都大于0，才会执行这条语句&quot;) 三条语句均可输出 if判断条件还可以简写为： if x: print(&#39;True&#39;) 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False 2. 多重条件语句当然仅仅依靠if else进行语句判断是很粗糙的，我们还可以进行多重条件语句判断。 例如当我们需要检查超过两个的情形，为此可使用Python提供的if-elif-else结构，Python只会执行if-elif-else结构中的一个代码块，他会依次检查每个条件测试，直到遇到通过了的条件测试，测试通过Python将会执行紧跟在他后面的代码，并跳过余下的测试。 age = 7 if age &gt; 10: print(str(age) + &quot;大于10&quot;) elif age &gt; 8: print(str(age) + &quot;大于8&quot;) elif age &gt; 6: print(str(age) + &quot;大于6&quot;) else: print(str(age) + &quot;小于等于10&quot;) 3.嵌套条件语句当一些判断条件在只有当前提条件满足时，才可以去判断后续条件是否满足。 嵌套条件是指在已有的一个if语句块中插入另一个if语句块，实现条件的嵌套判断，if语句可以多层嵌套。 并且由于Python使用强制缩进使代码正确对齐，让程序员来决定else属于哪一个if，从而减少了不确定性。 注意input（） 根据用户输入的随机值来判断该值为正数、负数还是零 s = input(&#39;num:&#39;) #这是因为input()返回的数据类型为str，str不能与int进行比较，所以在这里我们需要用到Int()函数来实现这个功能。 num = int(s) if num &gt;= 0: if num == 0: print(&quot;零&quot;) else: print(&quot;正数&quot;) else: print(&quot;负数&quot;) 并且当用户输入的值不是一个int类型值后，int()函数就会报错，程序退出。 - 循环 Python的循环有两种，一种是for…in进行循环遍历，依次把list或者tuple中的每个元素迭代出来 languages = [“C”, “Java”, “Python”, “NodeJs”]for x in languages: print(x) 打印结果： C Java Python NodeJs Process finished with exit code 0 使用for循环还有一个很常用的地方是输出数字，例如 # 等同于for i int rang(10) for i in range(1,10): print(i) 输出： 0 1 2 3 4 5 6 7 8 9 Process finished with exit code 0 第二种循环是while循环，条件满足则会一直进行循环，条件不满足时则会跳出循环。 i = 1sum = 0while i &lt;= 100: sum = sum + i i=i+1 print(sum) 计算1+2+3+… 当i=101时则退出循环，所以结果为当初高斯同学运算出来的5050 break 在循环中，break可提前结束循环 i = 1sum = 0while i &lt;= 100: sum = sum + i i=i+1 if i == 11: break print(sum) 运算1+2+3+…，但是当i=11时，我们就会退出for循环，只加到10 continue 再循环过程中，也可通过continue语句，跳过当前的这次循环，直接开始下一次循环。 i = 0while i &lt; 10: i = i + 1 if i % 2 == 0: continue print(i) 打印出来的值为： 1 3 5 7 9 Process finished with exit code 0 该程序本是可以打印1~10的所有数字，但是由于if语句中，判断出只有i为偶数，就会跳出本轮循环，并直接开始进行下一轮循环。","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://123.56.84.132/public/tags/python/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"（五）python数据类型（下）","slug":"16","date":"2020-02-08T09:55:39.000Z","updated":"2020-03-06T05:38:55.358Z","comments":true,"path":"2020/02/08/16/","link":"","permalink":"http://123.56.84.132/public/2020/02/08/16/","excerpt":"","text":"python标准数据类型有Number(数字)，String（字符串 ,Boolean(布尔值)，List（列表），Tuple（元组），Set（集合），Dictionary（字典） Number、String与Boolean在上一章节我们已详细讲解，这一章我们主要讲解剩下部分 - listPython内置的一种数据类型是list，list是一种有序结合。例如： language = [&#39;C&#39;,&#39;Java&#39;,&#39;python&#39;,&#39;NodeJs&#39;] print(language) #打印列表language print(type(language)) #type()函数可获取该数据的数据类型，并打印出来 print(len(language)) #len()函数可获取list元素的个数，并打印出来 打印结果为： [&#39;C&#39;, &#39;Java&#39;, &#39;python&#39;, &#39;NodeJs&#39;] &lt;class &#39;list&#39;&gt; 4 如果我们想要访问list的每一个位置的元素，记得索引是从0开始，索引的最大值为len(list) - 1。 language = [&#39;C&#39;,&#39;Java&#39;,&#39;python&#39;,&#39;NodeJs&#39;] print(language[0]) #获取list的第一个值 print(language[1]) #获取list的第二个值 print(language[2]) #获取list的第三个值 print(language[3]) #获取list的第四个值 print(language[len(language) - 1]) #获取list的最后一个值，等同于print(language[3]) print(language[-1]) #获取list的最后一个值，等同于print(language[3])，该索引会直接获取list的最后一个值 #以此类推可以获取list倒数第二个值，倒数第三个值，也不可超过list个数上线 打印为： C Java python NodeJs NodeJs NodeJs 由于list是一个可变的有序表，所以我们也可对list进行追加、插入、删除、查询等相关操作。例如： num = [1 , 2 , 3] print(num) num.append(4) #通过append()函数，在num末尾进行追加 print(num) num.insert(0,7) #通过insert()函数，把元素插入到指定位置。比如在索引号为0的位置追加数字 7 print(num) num.pop() #通过pop()函数，删除list末尾的元素 print(num) num.pop(0) #我们也可通过pop(i),i为索引位置，进行指定删除某个元素 print(num) num[0] = &quot;替换成功&quot; #我们也可把某个元素替换成别的值，一个list内可包含多种不同数据类型的值 print(num) 打印为： [1, 2, 3] [1, 2, 3, 4] [7, 1, 2, 3, 4] [7, 1, 2, 3] [1, 2, 3] [&#39;替换成功&#39;, 2, 3] list还有很多自带的函数，下面把一些常用地函数一一列给大家 language = [&#39;C&#39;,&#39;Java&#39;,&#39;python&#39;,&#39;NodeJs&#39;] num = [1 , 2 , 3 , 1] list2 = language + num #列表组合 print(list2) #打印列表组合list2 print(max(num)) #使用max()函数获取list num的最大值，并打印出来 print(min(num)) #使用min()函数获取list num的最小值，并打印出来 print(num.count(1)) #查看元素1在list num中出现过的次数 num.reverse() #使list num进行倒序排列 print(num) num.sort() #使list num进行升序排列 print(num) num.clear() #清除列表中的所有数据 print(num) num.extend([5,6,7]) #向list num末尾一次性追加多个值 print(num) print(5 in num) #判断5是否存在于list num中 print(1 in num) #判断1是否存在于list num中 打印为： [&#39;C&#39;, &#39;Java&#39;, &#39;python&#39;, &#39;NodeJs&#39;, 1, 2, 3, 1] 3 1 2 [1, 3, 2, 1] [1, 1, 2, 3] [] [5, 6, 7] True False 二维数组：list1 = [1,2,[11,12,12]] print(list1) #打印二维数组list1 print(list1[2]) #打印二维数组的第三个值，也就是list1中所包含的list print(list1[2][0]) #打印所包含的list里的第一个值 打印为： [1, 2, [11, 12, 12]] [11, 12, 12] 11 - tuple另一种有序列表叫做元组，即tuple。tuple与list很相似，但是tuple是不可变的列表，一旦初始化就不可修改，与list相比较为安全。 定义tuple：language = (&#39;C&#39;,&#39;Java&#39;,&#39;python&#39;,&#39;NodeJs&#39;) #初始化一个tuple print(language) top = () #初始化一个为空的tuple print(top) top2 = (1) #但如果初始化的tuple只有一个值，则打印出来的则只为tuple内的元素，这就违背了tuple的定义，所以我们为了杜绝这种情况，当tuple内只有一个元素时，应该采用以下写法 print(top2) top3 = (1,) print(top3) 打印为： (&#39;C&#39;, &#39;Java&#39;, &#39;python&#39;, &#39;NodeJs&#39;) () 1 (1,) 其他操作 由于tuple初始化成功后不可改变，所以不可以进行修改。只能进行查询与取值，但如果tuple内存在list，list内的值是可以更改的。 language = (&#39;C&#39;,&#39;Java&#39;,&#39;python&#39;,&#39;NodeJs&#39;) print(language[0]) #根据索引查询tuple内的第一个值 print(language[3]) #根据索引查询tuple内的第四个值 print(language[-1]) #根据索引查询tuple内的最后一个值 print(&#39;C&#39; in language) #判断字符串&#39;C&#39;是否在tuple内 del language #删除tuple #注意！删除tuple即代表不存在，而不像list清空元素，因为tuple定义后即不可更改 打印为： C NodeJs NodeJs True - dict Python内置了字典：dict，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 dict特性：使用键值对（key-value）存储，value 是我们要存储查找的数据，key是我们要找到数据的钥匙。key必须是唯一且不可变的对象。 grade = {&quot;tom&quot;:50,&quot;boby&quot;:60,&quot;grad&quot;:99} #定义dict print(grade) #输出dict print(grade[&quot;boby&quot;]) #根据key进行索引查询，若所查询的dict中并没有这个key，则系统会报错 grade[&quot;boby&quot;] = 0 #更改key为boby的值 print(grade[&quot;boby&quot;]) #而为了判断dict是否拥有这个key，有以下两种方法 print(&quot;boby&quot; in grade) #若不存在，则会返回False print(grade.get(&quot;boby&quot;)) #若不存在，则会返回None print(grade.get(&quot;boby&quot;,-1)) #若不存在，也可返回自己所定义的value 打印为： {&#39;tom&#39;: 50, &#39;boby&#39;: 60, &#39;grad&#39;: 99} 60 0 True 0 0 由于dict内部存放的顺序和key放入的顺序是没有关系的，所以插入、删除、查询一切都是根据dict内的key的值。 grade = {&quot;tom&quot;:50,&quot;boby&quot;:60,&quot;grad&quot;:99} #定义dict grade[&#39;join&#39;] = 88 #向grade中添加数据，key为join，value为88 print(grade) grade.pop(&#39;boby&#39;) #删除key为boby的这一组数据 print(grade) # 遍历,循环出的所有的value值 for i in grade.values(): print(i) grade.clear() #清空dict del grade #删除dict 打印为： {&#39;tom&#39;: 50, &#39;boby&#39;: 60, &#39;grad&#39;: 99, &#39;join&#39;: 88} {&#39;tom&#39;: 50, &#39;grad&#39;: 99, &#39;join&#39;: 88} 50 99 88 - setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 由于key必须是唯一的且不可变的，所以set中所有的值也都要有这种特性的 在创建set需要一个list或者tuple或者dict作为输入集合，重复元素在set中可以重复添加但是会被自动过滤。 s1 = set([1,2,3]) #以list作为一个输入集合创建set print(s1) s2 = set((1,2,3,2,1)) #以tuple作为一个输入集合创建set，重复元素会被自动忽略 print(s2) s3 = set({1:&quot;one&quot;,2:&quot;two&quot;,3:&quot;three&quot;}) #以dict作为一个输入集合创建set，value会被自动忽略 print(s3) 打印为： {1, 2, 3} {1, 2, 3} {1, 2, 3} 其他操作： s1 = set([1,2,3,4]) #以list作为一个输入集合创建set s1.add(5) #添加元素5 s1.add(1) #添加元素1，但由于存在1所以此添加忽略 s1.add((7,8,9)) #添加元组，因为元组不可变，列表、字典均可变所以不可添加 print(s1) #打碎插入 s2 = set([1,2,3]) s2.update([4,5,6]) #打碎插入，插入整个List s2.update((6,7,8)) #打碎插入，插入整个Tuple s2.update(&quot;daab&quot;) #打碎插入，插入整个字符串 print(s2) s2.remove(1) #删除s2中值为1的key print(s2) a1 = s1 &amp; s2 #a1为s1与s2所有的交集 print(a1) a2 = s1 | s2 #a2为s1与s2所有的并集 print(a2) 打印为 {1, 2, 3, 4, 5, (7, 8, 9)} {1, 2, 3, 4, 5, 6, 7, 8, &#39;a&#39;, &#39;d&#39;, &#39;b&#39;} {2, 3, 4, 5, 6, 7, 8, &#39;a&#39;, &#39;d&#39;, &#39;b&#39;} {2, 3, 4, 5} {1, 2, 3, 4, 5, 6, 7, 8, (7, 8, 9), &#39;b&#39;, &#39;a&#39;, &#39;d&#39;}","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"python","slug":"python","permalink":"http://123.56.84.132/public/tags/python/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"(六) Linux的Firewalld防火墙","slug":"7","date":"2020-02-07T11:25:48.000Z","updated":"2020-03-06T05:38:56.100Z","comments":true,"path":"2020/02/07/7/","link":"","permalink":"http://123.56.84.132/public/2020/02/07/7/","excerpt":"","text":"Linux的Firewalld防火墙使用防火墙可以对外部的数据包进行过滤和阻止，尽可能减少暴露在网络上的危险以保护系统安全。在RHEL7系的Linux系统中，已经将iptables防火墙管理工具使用firewalld代替。这篇文章的所有案例在RHEL8上成功执行，如果遇到了问题请尝试变通或者在底部评论区与我留言。 1. firewalld防火墙简介firewalld提供了一个动态管理的防火墙，在对防火墙规则修改时不需要断开连接就可以激活规则，并且支持网络区域zones,用来分配一个网络及相关连接一种程度上的信任。它已经对IPv4和IPv6进行支持。并且可以选择对规则临时或永久修改。 1.1. firewalld与iptables的主要区别 iptables在/etc/sysconfig/iptables-config文件中存储配置。firewalld在/etc/firewalld/下存储XML配置文件。 使用iptables时每一个规则的更改意味着要清除所有旧的规则，然后从/etc/sysconfig/iptables-config配置文件中读取所有新的规则并载入。然而使用firewalld可以临时的将新添加的规则载入使用，不会像iptables一样丢失连接。 使用iptables命令行和firewalld工具和内核的NetFilter（内核防火墙框架）的交互示意图如下。 可以看出NetFilter才是真正的“防火墙”，它是Linux操作系统核心层内部的一个数据包处理框架，由图可以看出，不论是iptables命令行工具还是firewalld工具，它们都会通过iptables command与NetFilter(内核防火墙框架)放出来的接口实现沟通并使防火墙的规则生效。 1.2. 对firewalldZone网络区的理解基于对网络中的设备和通信所给予的信任程度不同，firewalld防火墙可以用来将网络分割成不同的区域。 使用firewall-cmd --get-zones查看默认提供的zone，这些zone提供了一些基本的规则，也可以修改并保存规则。比如在工作单位时我切换到homeZone来屏蔽大多数让我分心的网络连接，然而回家后我需要娱乐娱乐，此时我将Zone改为home或者我信任我家里的网络并且改为了trustZone，这样又可以悠闲的享受那些娱乐网站咯。 Zone类型 说明 block 封锁 任何的连接都会被拒绝接收，并返回icmp(6)-host-prohibited拒绝信息 dmz 非军事区 处于此区域的设备可以公开访问，可以有限制的进入内部网络，仅接收经过选择的连接 drop 抛弃 接收到的任何连接都会被悄无声息的抛弃掉，不返回任何相应，仅允许对外发出的连接 external 外部 不信任来自网络的所有连接，仅接收经过选择的连接 home 家庭区 用于家庭网络。信任网络中的大多数连接，仅接收经过选择的连接 internal 内部 与home提供的默认规则相同 public 公共 不能相信网络内的其他计算机不会对您的计算机造成危害，仅接收经过选择的连接 trust 信任 可以接受任何的网络连接 work 工作 与public提供的默认规则相同 上面的所有Zones每个网络接口可以使用一个Zone作为当前Zone。当接入网络连接后，NetWorkManager将被分配为你设定好的默认Zone网络区，firewalld默认的网络区为public。 2. 安装firewalld防火墙安装firewalld需要以root用户身份执行下面的命令，并且执行firewalld命令时也要使用root用户身份执行。 dnf install firewalld 如果你安装了系统图形界面，并且也想使用图形化工具来管理firewalld，请执行如下命令。 dnf install firewall-config 但是本文中不会涉及到使用图形化工具配置firewalld防火墙 2.1. 启动防火墙设置firewalld防火墙为默认防火墙并随着系统启动服务 systemctl enable firewalld 启动防火墙 systemctl start firewalld 如果对systemctl命令不了解，可以在浏览守护进程和控制服务相关博文。 2.2. 检查防火墙是否运行systemctl status firewalld.service systemctl status firewalld.service ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2020-02-05 08:03:45 CST; 10h ago Docs: man:firewalld(1) Main PID: 1539 (firewalld) Tasks: 2 (limit: 49252) Memory: 35.7M CGroup: /system.slice/firewalld.service └─1539 /usr/libexec/platform-python -s /usr/sbin/firewalld --nofork --nopid Feb 05 08:03:44 centos8 systemd[1]: Starting firewalld - dynamic firewall daemon... Feb 05 08:03:45 centos8 systemd[1]: Started firewalld - dynamic firewall daemon. 使用firewall-cmd --state也可以查看防火墙运行状态 firewall-cmd --state running # 运行中 3. 使用firewall-cmd进行管理3.1. Zone网络区管理3.1.1. 查看所有Zone网络区firewall-cmd --list-all-zones 列出所有Zone的配置规则 firewall-cmd --list-all-zones block target: %%REJECT%% icmp-block-inversion: no interfaces: sources: ... 还可以精简的只输出Zone的名字 firewall-cmd --get-zones 3.1.2. 查看firewalld默认Zonefirewall-cmd --get-default-zone firewall-cmd --get-default-zone public # `firewalld`默认Zone为public 3.1.3. 查询某个网络接口上使用的Zonefirewall-cmd --get-zone-of-interface=XXXX firewall-cmd --get-zone-of-interface=ens32 # 这里查看ens32网络接口当前的Zone public # 当前ens32接口上激活的是`public`Zone 3.1.4. 查看已激活的Zone的网络接口列表firewall-cmd --get-active-zones firewall-cmd --get-active-zones public interfaces: ens32 # 可以看到，当前只有public网络区被激活。并且只有一个网络接口`ens32`使用这个Zone 3.1.5. 查询某一个Zone的详细规则信息firewall-cmd --zone=public --list-all firewall-cmd --zone=public --list-all public (active) target: default icmp-block-inversion: no interfaces: ens32 sources: services: cockpit dhcpv6-client ssh ports: 8096/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: # 可以看到public网络区的规则信息：绑定了`ens32`网络接口，放行了cockpit dhcpv6-client ssh 服务的默认端口规则，还放行了8096的tcp端口。 3.1.6. 修改当前默认的Zone网络区比如设置默认网络区为public，更改会立即生效。此时此刻，所有接口上默认绑定的Zone网络区都会切换到新的这个publicZone网络区上。 firewall-cmd --set-default-zone=public 3.1.7. 修改网络接口上的Zone网络区如果有许多网络接口，要更改当前ens32网络接口绑定的Zone网络区为home，可以执行如下命令。 firewall-cmd --zone=home --change-interface=ens32 3.1.8. 删除绑定在网络接口上的Zone网络区如果你不想让某以网络接口绑定到任何的网络区上，你可以执行如下命令。但是这么做无异于裸奔在网络世界中！ firewall-cmd --remove-interface=ens32 firewall-cmd --remove-interface=ens32 You&#39;re performing an operation over default zone (&#39;public&#39;) but your connections/interfaces are in zone &#39;trusted&#39; (see --get-active-zones) You most likely need to use --zone=trusted option. # 由于没有加上--zone参数，这里给我们一个提示。 success 实际上任何一个网络接口都要绑定一个Zone网络区，如果将绑定的网络区删除，在reloadfirewall规则后会发现刚刚删除Zone的网络接口自动绑定到了trusted的Zone网络区，也就是说不受到防火墙的任何规则限制，比较危险。 3.2. 重新加载firewalld防火墙3.2.1. 不中断用户连接通常在对规则添加--permanent永久生效的选项后，规则不会立即生效，需要重新加载防火墙后配置的永久规则才会生效。在不中断用户现有的连接的情况下，建议使用firewall-cmd --reload来重新加载防火墙。 firewall-cmd --reload 3.2.2. 完全重载防火墙，并断开现有的用户连接通常在firewalld防火墙出现问题时才会使用这种方式重载防火墙，这种方式会断开现有的网络连接，即丢失状态信息！ firewall-cmd --complete-reload 3.3. 打开/关闭防火墙端口(放行端口)如果本地需要开放一个端口供外部访问，那么你可以将这个端口添加到某一网络区的放行端口规则中。 3.3.1. 打开防火墙端口(放行端口)firewall-cmd --add-port=portid[-portid]/protocol [--permanent] [--zone=zone] 参数(portid[-portid]):要开放的端口号，如果是一个范围则使用10000-12000表达一个范围。 参数(protocol):TCP/UDP协议 可选参数(zone):将规则添加到哪个Zone网络区中，如果缺省该参数则添加到默认Zone网络区中。 可选选项(–permanent):规则永久保存，重新加载防火墙后生效。如果缺省该参数则修改的规则立即生效，但是重新加载防火墙后规则会失效。 firewall-cmd --add-port=6000-7000/tcp --permanent --zone=public # 在public网络区下放行6000~7000之间TCP通信协议的网络端口(闭区间)，规则永久保存并且在下一次重新加载防火墙后生效。 success firewall-cmd --zone=public --list-all # 检查修改后的public网络区的规则，发现并没有新添加的放行端口规则，说明规则还没有生效，需要重新加在防火墙。 public (active) target: default icmp-block-inversion: no interfaces: ens32 sources: services: cockpit dhcpv6-client http https ssh ports: 8096/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: firewall-cmd --reload # 重新加载防火墙 firewall-cmd --list-all --zone=public # 再次检查规则是否生效。发现规则已生效。 public target: default icmp-block-inversion: no interfaces: sources: services: cockpit dhcpv6-client http https ssh ports: 8096/tcp 6000-7000/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 下面在默认的网络区内永久放行单个TCP端口 firewall-cmd --add-port=6000/tcp --permanent # 这里没有添加`--zone`的选项和参数，会自动添加到默认网络区中。 firewall-cmd --reload 重新加载防火墙，使规则生效。 3.3.2. 关闭防火墙端口(关闭端口)刚刚已经将端口放行，并且暴露在外。如果需要这个端口的服务不再使用，出于安全考虑你可以将这个端口从放行规则中删除掉。 firewall-cmd --remove-port=portid[-portid]/protocol [--permanent] [--zone=zone] 参数(–remove-port=portid[-portid]/protocol):你要移除的端口号/端口范围，注意表明是TCP协议还是UDP协议哦。和你添加的时候一样，如果添加时你写的是一个端口范围，那么删除时只能将全部的端口范围删除掉，不能只删除端口范围中一部分端口。 可选参数(–zone=zone)：关闭指定网络区中的端口，如果缺省该参数，则从默认的网络区中删除端口。 可选选项(–permanent)：规则永久保存，重新加载防火墙后生效。如果缺省该参数则修改的规则立即生效，但是重新加载防火墙后规则会失效。 firewall-cmd --remove-port=8080/tcp --permanent #关闭默认Zone网络区开放的TCP8080端口 firewall-cmd --remove-port=1000-2000/udp --zone=public --permanent #永久关闭在public网络区下开放的UDP1000-2000端口。 3.4. 放行/关闭防火墙某一服务(放行服务)firewalld中存储了常见服务的默认端口信息，如果你的服务没有更改过默认的端口号，那么可以直接使用firewald放行服务，它会根据默认规则，自动放行一个或一组此服务需要的端口。只需要管理员来记忆服务名就好咯！ 3.4.1. 查看所有支持的服务firewall-cmd --get-services 你能看到所有firewald存储的默认服务端口号，如果此时你需要开启某一服务的端口就不需要记他们默认的端口号了，试试firewall-cmd --add-service=XXXX。 3.4.2. 查询服务端口详细信息刚才查询到了所有支持的服务，那firewalld给我们提供的默认服务的端口号究竟是啥呢？ firewall-cmd --permanent --service=https --get-port 返回443/tcp。 3.4.3. 放行服务端口firewall-cmd --add-service=service [--permanent] [--zone=zone] [--timeout=timeval] 参数(–add-service):要放行的服务名，如ssh、http、https。 可选参数(–zone=zone)：将此规则添加到网络区，如果缺省该参数，添加到默认网络区内。 可选参数(–timeout=timeval)：临时生效时间，不可与--permanent连用。表达方式可以是--timeout=[100s | 100m | 100h]。(timeval is either a number (of seconds) or number followed by one of characters s(seconds), m(minutes), h(hours)) 可选选项(–permanent)：规则永久保存，重新加载防火墙后生效。如果缺省该参数则修改的规则立即生效，但是重新加载防火墙后规则会失效。 firewall-cmd --add-service=https --permanent #永久放行在默认网络区内的https(443端口)服务 firewall-cmd --add-service=https --timeout=1h #临时放行在默认网络区内的https服务1小时 firewwall-cmd --add-service=https --zone=home --permanent #永久放行在home网络区中的https服务 3.4.4. 关闭服务端口如果关闭某一服务所对应的端口，那么将会时该服务无法对外部提供服务，请确定好删除的服务名，以免影响业务的正常服务！ 你可以通过firewall-cmd --list-all查看默认网络区下，当前开放了哪些服务与规则，确保在关闭之前，这些服务和端口是开放的状态。 firewall-cmd --remove-service=https [--permanent] [--zone=zone] 参数与规则与关闭端口类似，在此不再赘述。 3.5. 端口转发端口转发可以将到达某一端口的数据包转发到本机或其他机器上另一个的一个端口上。使用端口转发功能需要现开启firewalld的IP伪装功能。 使用firewall-cmd --list-forward-ports可以查询所有端口转发规则。 3.5.1. 开启IP伪装防火墙可以实现IP伪装，默认为关闭状态。可以使用firewall-cmd --query-masquerade进行查询。 firewall-cmd --query-masquerade查询默认Zone网络区内的ip伪装功能是否开启。 返回no则为关闭状态。 firewall-cmd --add-masquerade [--permanent] [--zone=zone] [--timeout=timeval] 参数(–add-masquerade):开放IP转发功能。 可选参数(–zone=zone)：将此规则添加到网络区，如果缺省该参数，添加到默认网络区内。 可选参数(–timeout=timeval)：临时生效时间，不可与--permanent连用。表达方式可以是--timeout=[100s | 100m | 100h]。 可选选项(–permanent)：规则永久保存，重新加载防火墙后生效。如果缺省该参数则修改的规则立即生效，但是重新加载防火墙后规则会失效。 如果不需要IP地址伪装，使用下面的命令关闭。 firewall-cmd --remove-masquerade [--permanent] [--zone=zone] 3.5.2. 开启端口转发请确保在开启端口转发前已经开启IP伪装功能。 firewall-cmd --add-forward-port=port=portid[-portid]:proto=protocol[:toport=portid[-portid]][:toaddr=address[/mask]] [--permanent] [--zone=zone] [--timeout=timeval] 参数(–add-forward-port): portid:本机端口号 protocal:UDP/TCP协议，此处只能选择一个。 [portid]:要转发到的端口。如果缺省该参数则默认与设置的本地端口一致。 [address]:要转发到的地址。如果缺省该参数则默认为本机地址。 可选选项(–permanent)：规则永久保存，重新加载防火墙后生效。如果缺省该参数则修改的规则立即生效，但是重新加载防火墙后规则会失效。 其他参数不再赘述。 下面是一些使用端口转发的案例： firewall-cmd --add-masquerade # 开启IP伪装（转发到其他IP上时必须开启，仅转发本地端口则非必须开启） firewall-cmd --add-forward-port=port=8888:proto=udp:toport=53 --permanent #永久将本机默认网络区下的本地UDP8888端口转发到本地UDP53端口上。 firewall-cmd --add-forward-port=port=7777:proto=tcp:toport=6667:toaddr=192.168.1.160 --zone=public #临时在public网络区下将本机7777端口的TCP流量转发到192.168.1.160上的6667端口上，重载防火墙后失效 firewall-cmd --add-forward-port=port=7777:proto=tcp:toport=6667:toaddr=192.168.1.160 --timeout=100s #临时在100秒内将默认网络区下将本机7777端口的TCP流量转发到192.168.1.160上的6667端口上，超时或重载防火墙后失效。 3.5.3. 关闭端口转发使用 firewall-cmd --list-forward-ports查询当前已加载所有的端口转发规则 firewall-cmd --list-forward-ports #查询当前已加载所有的端口转发规则 port=8888:proto=udp:toport=53:toaddr= #发现有一个转发规则 当不需要这个规则时我们可以删除它。 firewall-cmd --remove-forward-port=port=portid[-portid]:proto=protocol[:toport=portid[-portid]][:toaddr=address[/mask]] [--permanent] [--zone=zone] [--timeout=timeval] 参数部分不再赘述。与添加时的意思相对应。可以先查询规则，确定好你要删除的规则后将规则填写到--remove-forward-port=后即可。 注意：如果你添加端口转发规则时，选择了--permanet永久生效,那么在永久删除时也要添加上--permanet选项。除非是想临时取消此这条规则。 firewall-cmd --list-forward-ports #查询当前已加载所有的端口转发规则 port=8888:proto=udp:toport=53:toaddr= #发现有一个转发规则，现在删除此规则。 firewall-cmd --remove-forward-port=port=8888:proto=udp:toport=53:toaddr= --permanet # 在默认的网络区内永久删除这条转发规则。 firewall-cmd --reload #使修改生效 待续","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"linux","slug":"linux","permalink":"http://123.56.84.132/public/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"树莓派编译安装Mysql5.7","slug":"8","date":"2020-02-02T10:59:39.000Z","updated":"2020-03-06T05:38:56.108Z","comments":true,"path":"2020/02/02/8/","link":"","permalink":"http://123.56.84.132/public/2020/02/02/8/","excerpt":"","text":"提示 因为编译Mysql5.7 占用内存过大不建议树莓派3b,3b+,4b（1G内存版）使用Mysql5.7，上述型号推荐5.5/5.6. 下载安装包wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz tar zxf lnmp1.6.tar.gz cd lnmp1.6 开始安装sudo ./install.sh db 如图： 此处选择：4 回车后如图： 此处创建数据库root用户的密码。 回车后如图： 此处开启inodb引擎，输入：y 连按两次回车，开始安装。","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}]},{"title":"（学前准备）linux安装及使用虚拟机安装","slug":"24","date":"2020-02-02T01:36:39.000Z","updated":"2020-03-06T05:38:55.586Z","comments":true,"path":"2020/02/02/24/","link":"","permalink":"http://123.56.84.132/public/2020/02/02/24/","excerpt":"","text":"往往大家在使用Linux时一般会在虚拟机上使用当然也会有直接装在物理机上使用和在以后工作中直接部署在服务器上这是部署方法就有很多了 今天我就先给大家介绍虚拟机的安装和使用 我所用的操作系统为Windows所以选择用的为VMware Workstation Pro 一般大家使用的虚拟机都会选择VMware macos会使用VMWare Fusion Pro 当然macos也有自己的虚拟机Parallels Desktop 大体使用相同 我今天就给大家介绍Workstation Pro 需求准备： 1.首先你可以选择去VMware官网上下载但是比较繁琐你也可以选择去42下载站下载更方便 2.将你物理机的虚拟化功能打开（以我的联想笔记本为例给大家介绍，进入BIOS 切换至Configuration菜单，在该页面中，选择Intel Virtual Technology设置选项。打卡该选项 保存并推出） 正式开始安装： 1.打开.exe文件， 即可开始安装。 2.安装位置默认在C盘下，在这里我选择安装在F盘，安装路径尽量不要有中文。 3.等待安装就好了。 安装成功后，第一次运行程序会要求输入密钥，这个可以自己百度，下面分享我搜集的密钥 UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA VF750-4MX5Q-488DQ-9WZE9-ZY2D6 UU54R-FVD91-488PP-7NNGC-ZFAX6 YC74H-FGF92-081VZ-R5QNG-P6RY4 YC34H-6WWDK-085MQ-JYPNX-NZRA2 5.输入密钥后，如果成功的话将出现如下界面。 安装版本为14 目前已经出现15但是在安装上不会有差距 我将会在使用上给大家介绍15版本","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"（五）Linux SSH远程访问命令行","slug":"15","date":"2020-02-01T11:40:43.000Z","updated":"2020-03-06T05:38:55.342Z","comments":true,"path":"2020/02/01/15/","link":"","permalink":"http://123.56.84.132/public/2020/02/01/15/","excerpt":"","text":"SSH远程访问SSH 是什么SSH是OpenSSH Secure Shell通用的简称，OpenSSH Secure Shell(SSH)是用来在远程设备的操作系统上安全运行Shell，只需要提供远程目的设备系统的用户信息并且完成身份认证就可以对登录到该系统执行命令了。 SSH的食用方法ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J destination] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] destination [command] 这么看的话选项和参数有点多！不过常用的仅仅几个，下面的例子会介绍SSH的常见使用方法。 默认SSH服务器的远程端口是22，也就是说在没有指定[-p port]选项时假定ssh服务端口就是22。如果你出于安全考虑，将OpenSSH服务器上对外暴露的端口修改为其他端口号上，那么在远程访问服务器时使用ssh需要手动指定-p 端口号才能与你的SSH服务器建立连接。 登录远程设备系统使用远程系统的用户名来登录远程设备系统ssh &lt;username&gt;@&lt;remote_address&gt; 参数1(username):指定要登录到远程设备的用户名 参数2(remote_address):远程设备的IP地址或域名 例如： ssh root@yeefire.com 以root用户身份(用户名)来登录yeefire.com域名的IP所指向的远程服务器系统。 使用当前用户身份，登录远程设备的系统ssh yeefire.com 使用你执行ssh命令的这个用户身份来登录到yeefire.com上，假定你现在的用户身份名为root那么可以理解为上面的命令被解析为ssh root@yeefire.com 使用w命令看看谁现在登陆了这台系统w w 14:55:29 up 17:01, 1 user, load average: 1.39, 1.49, 1.52 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT pi pts/2 192.168.1.194 12:53 0.00s 0.11s 0.01s w 在上面可以看到，用户名，使用的是什么终端，从些远程位置进行了登录以及登陆时间。 SSH公钥为了确保与服务器之间保持安全的网络通信，当从SSH客户端登录远程设备系统时，在该客户端开始登陆前，客户端会向目标索取服务器公钥，如果第一次与服务器链接会让你确认服务器公钥的准确性(防止中间人攻击)，一旦接受了公钥，就会保存在~/.ssh/known_hosts文件中，并且每次与远程设备系统设备链接时会与本机系统第一次保存的公钥进行比对，如果发现不匹配则立即拒绝并断开链接，并假定网络通信已遭劫持或服务器被入侵。 但是，当你给远程的设备重做了系统，由于重新生成了公钥会和你本机系统SSH客户端存储的公钥不一致，所以也会断开连接。如果你确信你当前的网络不存在安全问题，你可以在~/.ssh/known_hosts文件中删除旧的公钥记录，便可以重新与远程服务器进行建立可靠连接并登录。 配置SSH免密登录使用公钥身份验证即可对SSH登录进行身份验证，而不需要输入密码。执行ssh-keygen命令生成密钥，其中生成的私钥保存在~./ssh/id_rsa，公钥保存在~./ssh/id_rsa.pub 注意，你的私钥一定要保存好，它现在相当于你的登录密码！如果私钥被盗取，那么其他人可以利用你的私钥毫不客气地远程SSH登录到你的系统并窃取你珍藏许久的小电影。 下面是配置免密SSH登录的顺序和例子： ssh-keygen生成密钥在你的本机系统上执行 ssh-keygen ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/username/.ssh/id_rsa): # 回车 Enter passphrase (empty for no passphrase): # 回车 Enter same passphrase again: # 回车 Your identification has been saved in /home/username/.ssh/id_rsa. Your public key has been saved in /home/username/.ssh/id_rsa.pub. The key fingerprint is: SHA256:0kyfGMx571yKfjmtmMwnEYeJp2BYgf5yi0qWXCr18/k username@centos8 The key&#39;s randomart image is: +---[RSA 3072]----+ | ... | | . .o . | | . o *..o | | o o+.==o. | | . .o..Sooo. . | | o =. o.. .+ o | |. * o+ . ..+o | | + .o.. +.o= . | | .. o.E *+.o | +----[SHA256]-----+ 在生成密钥的过程中，会询问你密钥保存位置。也会询问你”二次认证”的密码(不需要再为私钥设置密码，全部回车即可！我们目的就是配置免密登录。如果你此处输入了密码，那么在使用私钥认证的时候仍然需要进行密码认证。但是设置私钥密码的好处是当你私钥被盗后，你有时间在对方破解你的私钥密码时重新生成一对密钥来保护你的系统)。此处全部直接回车即可。 ssh-copy-id发送公钥现在已经生成了本机的私钥与公钥，将本机的公钥发送给你的远程设备系统即可实现免密登录。 ssh-copy-id &lt;username&gt;@&lt;remote_address&gt; 参数1(username):指定要登录到远程设备的用户名 参数2(remote_address):远程设备的IP地址或域名 之后输入SSH登录密码，便会将公钥发送到远程设备的默认公钥存储位置存储。 现在，你当你ssh &lt;username&gt;@&lt;remote_address&gt;时，你会发现不需要输入密码即可登录到远程设备的系统上了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"linux","slug":"linux","permalink":"http://123.56.84.132/public/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"C++ const与static用法","slug":"37","date":"2020-02-01T05:26:41.000Z","updated":"2020-03-06T08:48:17.912Z","comments":true,"path":"2020/02/01/37/","link":"","permalink":"http://123.56.84.132/public/2020/02/01/37/","excerpt":"","text":"const 用法 定义使初始化 修饰指针,分别为指向常量的指正和指针常量 定义const函数形参,函数内部不能修改 成员函数为常函数,不能修改成员变量 成员函数返回常对象 类的成员变量是常量不能声明时初始化,必须构造函数列表进行初始化 常量引用,用于形参可以避免拷贝和函数对值的修改 // 类class A{private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 };void function(){ // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = &amp;a; // 常指针 const A &amp;q = a; // 常引用 // 指针 char greeting[] = &quot;Hello&quot;; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量 char* const p3 = greeting; // 常指针，指向字符数组变量 const char* const p4 = greeting; // 常指针，指向字符数组常量 }// 函数void function1(const int Var); // 传递过来的参数在函数内不可变void function2(const char Var); // 参数指针所指内容为常量void function3(char const Var); // 参数指针为常指针void function4(const int&amp; Var); // 引用参数在函数内为常量// 函数返回值const int function5(); // 返回一个常数const int function6(); // 返回一个指向常量的指针变量，使用：const int p = function6();int const function7(); // 返回一个指向变量的常指针，使用：int const p = function7();// 注意千万不要返回指向局部对象的指针，因为一旦函数结束，局部对象被释放，返回的指针变成了指向一个不再存在的对象的悬垂指针。 const int a; a为常整数 const int *a; a为指向常整数的指针,整数不可修改,指针可以 int * const a; a为指向整数的常指针,整数可以修改,指针不可以修改 如何做到只读 整型数使用常数直接替换对此变量的引用 static用法 1.修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 2.在模块内,一个声明为静态的变量可以被模块内函数访问,但不能为模块外的其他函数访问,为本地的全局变量 3.修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static 4.类内的static成员变量属于整个类拥有,不能在类内定义,只能在类的作用域内定义 5.类内的static成员函数属于整个类,不能包含this指正,只能调用static成员函数 6.修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员 static全局变量与普通的全局变量区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"C++","slug":"代码学习/C","permalink":"http://123.56.84.132/public/categories/代码学习/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://123.56.84.132/public/tags/C/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"C++","slug":"代码学习/C","permalink":"http://123.56.84.132/public/categories/代码学习/C/"}]},{"title":"（四）python数据类型（上）","slug":"26","date":"2020-01-31T15:54:14.000Z","updated":"2020-03-06T05:38:55.646Z","comments":true,"path":"2020/01/31/26/","link":"","permalink":"http://123.56.84.132/public/2020/01/31/26/","excerpt":"","text":"要注意的地方在学习python的基础知识之前，我们需要知道python代码在编写中有哪些要需要注意的地方 - 注释1. 单行注释Python中使用#表示单行注释。单行注释可以作为单独的一行放在被注释代码行之上，也可以放在语句或表达式之后 #这是单行注释，写在代码行之上 print(&quot;hello World&quot;) # 这是单行注释，写在代码行之后，同样为了保证代码的可读性，建议注释与代码之间保持两个空格 2. 多行注释（块注释）当注释内容过多，导致一行无法显示时，就可以使用多行注释。Python中使用三个单引号或三个双引号表示多行注释。 &#39;&#39;&#39; 这是三个单引号的多行注释 &#39;&#39;&#39; &quot;&quot;&quot; 这是三个双引号的多行注释 &quot;&quot;&quot; - 代码缩进一般代码都是通过{}或end来作为代码块的标记，而Python则是通过缩进来进行识别代码块,如： def sum(a,b): sumUp=a+b return sumUp print(sum(2,3)) 需要注意的是，虽然Python语法允许代码块随意缩进几个空格，但是位于同一个代码块中的所有语句必须保持相同的缩进，我们一般只使用一个tab。 - 数据类型与变量- 变量Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建,变量名必须是大小写英文、数字和_的组合，且不能用数字开头。 等号（=）用来给变量赋值。 a = 1 # a为整数 a = &quot;重新赋值&quot; # a被重新赋值 a_str = &quot;abc&quot; #a_str为一个字符串，且命名方式为下划线式命名 aBool = True # aBool是一个布尔值，且命名方式为驼峰式命名 请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。 Python的标准数据类型我们将在下一章节进行讲解 而在Python中能够直接处理的数据类型有以下几种： int (整数)、float (浮点型)、str(字符串)、bool (布尔值)、空值 - 整数Python可以处理任意大小的整数，也包括负整数，例如：1，100，-8080，0，等等。 a = 1 #正整数 b = -1 #负整数 - 浮点型浮点数也就是小数，之所以称为浮点数。浮点数可以用数学写法，如1.23，3.14，-9.01等。但是对于很大或很小的浮点数，则需要使用用科学计数法表示，把10用e替代，例如：1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 a = 3.14 b = -5.12 c = 1.2e2 #即1.2x10² - 字符串字符串是以 &#39;&#39; 或 &quot;&quot; 括起来的任意文本，但是 &#39;&#39; 与 &quot;&quot; 其本身只是一种表示方法，并不是字符串的一部分。 但是如果字符串中包含 &#39; 或 “ 时，我们则需要使用转义字符 \\ 来进行标识,比如： a = &quot;abc&quot; b = &quot;思思念念 abc&quot; c = &quot;I&#39;m OK!&quot; d = &quot;I&#39;m \\&quot;OK\\&quot;! &quot; #若 &quot; 不通过转义字符进行标识，则会出现字符串中的 &quot; 和包裹字符串的 &quot; 混合 print(a) print(b) print(c) print(d) 打印出来的结果为: abc 思思念念 abc I&#39;m OK! I&#39;m &quot;OK&quot;! 转义字符 \\ 可以转移很多字符，比如 \\n 表示换行， \\t 表示制表符,显示字符 \\ 本身也是需要通过转义字符 \\\\ 进行表达。 如果字符串里面有很多字符都需要转义，就需要加很多 \\ ，为了简化，Python还允许用 r&#39;&#39; 表示’’内部的字符串默认不转义。 print(&quot;I\\&#39;m fine&quot;) print(&quot;I&#39;m love \\n Python&quot;) print(&#39;\\\\\\n\\\\&#39;) #通过 \\\\ 来表达 \\ print(r&#39;\\\\\\n\\\\&#39;) #r&#39;&#39; 使 &#39;&#39;内部字符串默认不转义 值为： I&#39;m fine I&#39;m love Python \\ \\ \\\\\\n\\\\ - 布尔值一个布尔值只有一个True、False两种值，在Python中也可直接用True或False来表示布尔值（但请注意大小写），也可以通过布尔运算计算出来。 print(True) #打印True print(False) #打印False print( 2 &gt; 1) #判断 2 是否大于 1，若大于则打印True print(len(&quot;abc&quot;) == 2) #len()函数为计算一个字符串的长度，判断字符串&quot;abc&quot;的长度是否等于3，若是，则打印True。判断是否绝对等于需要使用 == print(type(1) == int) #type()函数是判断数据类型，判断数字1的数据类型是否为int，若是则打印True 结果： True False True False True - 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"python","slug":"python","permalink":"http://123.56.84.132/public/tags/python/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"（三）pycharm编辑器安装与使用","slug":"31","date":"2020-01-31T15:37:49.000Z","updated":"2020-03-06T05:38:55.823Z","comments":true,"path":"2020/01/31/31/","link":"","permalink":"http://123.56.84.132/public/2020/01/31/31/","excerpt":"","text":"这篇博文将带领大家学习和使用python类非常优秀的编译器——JetBrains Pycharm的基础使用。这里以Windows环境为例 准备环境与条件 python for Windows 3.8.1 x64 Windows 10 专业版 1909 版本为10.0.18363.418 Jetbrains PyCharm Professional 2019.3.2版 下载和安装我们以Professional(专业版)为例，进行下载安装 访问JetBrians官网JetBains,找到Tool——PyCharm,下载。 如果你在本校校园网内，处于校园网条件下，访问42Team下载站，搜索，享受高速下载 如需加快下载，可使用其他下载工具下载。比如FDM(Free Download Manager),IDM(Internet Download Manager),迅雷等。 点击后 根据你所使用的操作系统进行下载 点击下载。速度还是不错的！！！ 笔者在写博文时，就下载好了。让它继续下吧，我们来看看后续的步骤。 下载好的安装包长这样，看看下载对没，截至目前本文发布前最新的版本时2019.3.2 双击或以管理员身份运行 点击“Next” 笔者就按默认安装，读者也可以自定义来安装到其他盘。 注意！最好不要用中文或符号类的路径和文件夹名，防止安装或今后使用时出错！减少不必要的麻烦。同当时安装python时一样。 点击“Next” 在这里可以自定义勾选配置服务，也可以不勾选。笔者在这里都全选，之后会讲解他们分别有说明作用。 勾选完成，继续Next 点击“Install” 开始安装了。我们等待一下 继续上面的勾选服务介绍 第一个的意思是，在桌面创建图标，64位的启动器！ 第二个(右边那个)的意思是，将这个编译器添加到PATH里,不过它需要重启 第三个的意思是，加入到右键菜单，作为项目打开这个文件夹 第四个的意思是，关联图标，以后以.py结尾的文件将自动以Pycharm打开 此时安装完成，软件默认选择”I want to manually reboot later”,提醒我，“我想稍后重启”。跟我想的一样，一会儿在重启吧。你也可以直接选择”Reroot Now”,”现在重启”，看你咯！ 我们点击图标，开始使用.默认是选择第二个,不做导入设置.毕竟我们这是一个新的开始,没啥要导入.如果你有之前的软件配置的话,选一个,找到你的配置文件路径,软件开始给你配置. 安装许可,你懂的!记得打条,点击”Continue”(继续).右面的是”Reject And Exit”(拒绝并退出) 这里它问你,要不要数据分享.我想你也知道该怎么做, 注意：首次启动需要大量资源来配置初始化，启动会忙慢些，属于正常! 这里是设置UI注意，换句话说就是设置皮肤！有深夜和白色两个背景皮肤，默认选择第一个“Darcula” 如果你懒得设置或直接选默认，可以点击“Skip Remaining and Set Defaults”(跳过剩余部分，设置默认值)。直接进入软件界面 这里是选择下载插件设置，例如有Markdown和R语言。这篇博文就是用markdown来写的，我们可以直接在这里下载就行，软件会在设置完成后，可以使用。关于R语言，有需要的话可以在这里下载，安装完成后重新启动软件就可以在里面写R语言了。这也是之前跟大家说的，可以在软件里下载其他语言的插件，只需使用一个编译器的好处。笔者在这里暂不安装，之后将安装插件的几个方法。 设置完成后，点击”Start using PyCharm”(开始使用PyCharm)。 这是是要求填入激活信息。因为是专业版，需要额外收费。JetBrains系专业版软件支持三种激活方式，账户激活，激活码激活和许可服务器激活。 第一种激活方式是需要你用邮箱先注册一个JetBrains的账号，该账户有相关激活信息，可在这里填入用户名/邮箱，密码，验证该账户有相关激活信息即可使用。 第二种是激活码信息，可通过授权的激活码，在规定时期内，可以使用(一般大部分都是1年到期的)。 第三种是许可证服务器激活，若你拥有或在jetbrians公司购买授权搭建服务器的话，可以使用它。第二三中激活方法适用于组织或企业中。 笔者在这里使用免费使用30天的，选中”Evaluate for free“，在点击”Evaluate“. 启动界面，很漂亮吧.对了不要在意这个软件皮肤变成白色儿了,刚刚笔者软件开太多,占用后台资源太多,卡了下重启,它就这样了.没事儿的哈! 开始界面，有三个选项。”Create New Project“(建立新的项目，即新建项目)，”Open“(打开,即打开项目)，”Get from Version Control“(从版本控制得到，即从版本控制获取(git))。 因为这里我们是一个新的开始，本地没有项目，也暂不需从版本控制(git)获取开源项目。在这里我们选择第一个，Create New Project Localtion,在这里选择你的项目存放位置，最后面的”/“后，接你项目的名字，笔者这里直接选默认，读者可以根据自己的需求进行更改。 在PyCharm中，它会自己在，没一个python和python框架那跟随项目新建一个虚拟环境”venv“。这个在python的官方文档里就有体现。它也会存放在项目的储存位置那里。 Base interpreter，PyCharm会自己去找你安装的python解释器的位置。当然，如果它没找到的话，你可以自己去选路径进行配置。 配置完成后，点击”Create”。项目就开始创建了。 虚拟环境同时也被创建 如果设置的话，每次打开时，都会出现每日提示。帮助你更好的使用IDE，提升生产力。 这是项目创建好后，自带的东西。没有特殊需求的话，建议不要随便更改里面的东西，防止项目的不必要错误！ 注意：新建的项目文件，只能建立在项目里，不能建立在虚拟环境里(“venv”)。 建立一个基础python文件。建立的步骤 在这里起名 命名为test。建立好之后 我们来写个输出语句，输出它。同时检查编译器是否正常。 快速运行。在项目界面的空白界面—右键—”Run ’test‘ “。 点击OK 点击Apply,再点击”OK” 显示运行结果。 注意：在下方的输出框里，第二行是我们输出的语句内容。而第一行分别表示的是你虚拟环境下的python解释器的所在位置；你当前运行文件的所在位置。 这样，说明编译器可以正常使用。项目搭建也OK了 基础设置设置字体由于笔者是全屏截图，字体太小。这里也交大家一些基础的设置。打开”File“—找到”Settings“ 弹出”Settings“设置框——找到”Editor“——”Font“(字体)，进行设置。我把常用的都写在了截图里，对了，这个设置时可以实时预览的 设置背景如果你嫌黑色儿不太看清，可以这样设置为白色的皮肤。同理，找到设置 这就变为白色了 安装插件同理找到设置框，点击“Plugins”。Marketplace(市场)，即插件市场。我们可以在里面搜索下载我们需要的插件。Installed,即安装的插件，点击后可看到软件已经安装的插件。 已安装的插件。如果不想用的话，可以点击右侧插件介绍里的“Disable”，停用它，再点击“Apply“或”OK“。重启软件即生效 例如。我们安装一个Vue.js的插件。搜索框里填入”Vue.js“或”Vue“相关词语。找到想要的后，点击右侧的绿色小框”Install“，即可安装！ 安装中 安装完成后。点击”Restart IDE“，重启IDE，插件就可以使用了 弹出警告框，点击”Restart”,等待启动 让我们看看，插件可以用了么。在“File”—点击“New Project” 找到，最后一个Vue.js。这就跟前面的项目建立是一样的了 除了可以在设置里面安装插件，我们也可以通过其他方式安装插件 访问JetBrains官网插件选择下载 找到我们正在使用的IDE，看好自己选用的版本 这是对应版本的插件网站,我们搜索一下,想要的插件 注意:只有你想要搜索的那个插件已经在jetbrains家的插件市场上有,你才能搜到.同时要保证你输入的内容是正确的才行.要么就是没有或是不支持. 我们在网站上下载一个git(版本控制)插件 点击Get 在这里出现它的版本信息,我们找到指定的版本后下载,这里笔者选择第一个版本下载. 浏览器弹出下载信息 弹出选择插件文件的信息框,找到下载的插件所在位置.可以选择是.zip或解压后的.jar文件安装. 在这里笔者建议是.zip安装,因为从官网下载的就是.zip格式.而且解压后是一堆.jar文件,对选择上也是不方便,完整性没有更好的体现. 点击”OK”后 重启Restart IDE,同上述的安装插件步骤一致,这里不再赘述. 使用插件这里我们用markdown来演示和联系. 在我们的项目上,右键–”New”–”File”,填入文件名”说明.md”. 注意:在填写时,要写上文件后缀,以插件识别. 在里面写入内容.并却可以实时预览 由于篇幅和时间的原因,其他的小技巧和使用方法,在我们使用时遇到在讲了.","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"python","slug":"python","permalink":"http://123.56.84.132/public/tags/python/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"（二）python开发—IDLE","slug":"27","date":"2020-01-31T15:01:44.000Z","updated":"2020-03-06T05:38:55.678Z","comments":true,"path":"2020/01/31/27/","link":"","permalink":"http://123.56.84.132/public/2020/01/31/27/","excerpt":"","text":"这篇博客将介绍几个在学习python编程语言的“利器”！工欲善其事必先利其器！选好工具很重要。这里以Windows环境为例 本篇文章就图多点，大约5-6分钟，OK？ 在本文开始前，笔者在这里说几句。正值新春佳节，我国武汉发生了严重的传染肺炎，新型冠状病毒肺炎，全国各地启动了一级响应！严重性可想而知。作为寻常百姓，我们要谨记预防措施，少出门，勤洗手，多通风，不去人多的地方，不食用和交易野生动物！！！尽己之力，不为国家和社会添麻烦。在这里，祝大家新春快乐，身体健康，阖家欢乐！ 丁香园疫情实时情况 接上篇疑点在上篇里，提到“更改文件后缀名”，在Windows 10默认环境下，不会显示文件的后缀名，这里会告诉大家一个简便方法来显示文件后缀名 这里笔者以自己的文件来演示 这是默认时未显示 我们在这里将举例将“test_1”改为“test_1.py” 鼠标右键—“重命名”或直接按下F2键快捷更改 但发现，并未跟系统关联成python图标(在上一篇中，在选择默认安装时，python会关联.py文件并显示成python图标) 我们右键—“属性”，打开查看，发现并未是.py的文件类型 此时，我们应该开启显示文件后缀名。打开文件夹 找到上方的“查看“—点击”文件扩展名“ 这就显示了 最后我们按要求改为指定的文件后缀名就行了 提升学习效率，利器不可少！使用程序自带的编译器！ 上篇我们讲过，python在安装成功后，会在开始菜单里显示4个程序，今天我们就介绍一下他们各自的作用 IDLE—IDLE is Python’s Integrated Development and Learning Environment.(IDLE是Python的集成开发和学习环境。)它也是python的shell脚本 官网介绍 官网翻译 我们可以在IDLE里进行代码书写和学习 这里我们补充一个知识点 在命令行里的输出 调用sys模块(sys包) import syssys.stdout.write(‘Hello!This is IDLE!’) print 语句 print(‘Hello1 This is IDLE!’) 结果分别为 可见 引入或导入sys模块，书写输出语句，会返回语句内容，并统计字符数！括号内的内容须为字符型！包括空格和符号！！！。 直接使用print语句，则直接输出所填的内容。 值得注意的是 stdout只能输出字符串，如果要输出数字，必须先转成字符串的形式才可以；而print可以直接输出各种类型。 print语句执行的是一个写操作，把输入的数据写到了stdout流，并进行了一些特定的格式化。所以，print实际上就是调用了sys.stdout.write()，两者等价。 在python 3.8 (64-bit)里。命令行模式 在这里笔者觉得，IDLE和命令行在目前的使用中区别不大。 只是字体和背景不一样。？？？喵喵喵？ 我们再看下细节部分吧 对了，在IDLE中，tab键(制表符)可是一个好东西啊！用过类Unix系统的同学应该尝到甜头了吧！ 比如，在上面例子中。在敲代码中，给出词语的首字母，按下tab键，实现代码自动提示或自动补全。 还有代码高亮，只要输入的是关键字或保留字，代码会高亮，色儿也不一样。 废话一下。在敲sys时，我输入s时，按下tab键，sys自动补全了；在输入std时，按下tab键，出现以上代码提示，供选择。 但在命令行里，tab键只是一个空格键 注意光标的位置(那个白点) 可见，还是IDLE适合代码的学习和书写 Python 3.8 Manuals (64-bit)。自带的官方文档手册 里面有python 3.8.1版本的更新日志，python版本新变化，python官方文档(英文)，历史版本信息，许可证等等。是我们学习python的好教材！！！ Python 3.8 Module Docs (64-bit)。官方模块文档。 点击后，会出现这样的一个窗口 随后打开你本机的默认浏览器， 它在本地开启一个端口，启动服务，以网页的形式显示目前python自带的模块说明文档。供使用时学习和参考模块时的说明。 外面的编译器对于自带的python编译器，可能在用户的交互性，方便性等其他因素表现的并不是很好，因此，我们需要的其他的编译器来帮助我们！ 如果你在本校内，处于校园网条件下，可访问42Team下载站http://172.24.4.199 ，搜索下载这几个编译器 Jetbrains PyCharm Microsoft Visual Studio Microsoft Visual Studio Code 对于PyCharm和Visual Studio来说有付费专业版，而Visual Studio Code则是提供免费的使用。而前两者是在已安装好python开发环境下，软件自动完成(部分)编译器内的配置，也可手动配置；而最后者需要读者手动配置，里面提供了许多的插件库，可以自定义安装配置 笔者都使用过这三个软件，下面来进行简单的优缺点说明分析 对于JetBains PyCharm 优点 从安装完成后，软件配置基本是软件本身自动配置。你只需要关注你的项目名和存放位置。很方便，还剩时！！！ 提供流行的框架，看自己的项目框架选择自动或手动配置。 有丰富的插件库。可以在里面安装流行的插件。比如，在pycharm里写Java，也是可以的。只要去官方的插件网站上下载对应编译器的插件安装，配置就可以写了。 代码自动补全和自动提示。这个真的是爽的不行啊！！！这也是jetbrians全系软件的特色啊。每当自己写代码忘记或遗漏时，它会提醒你，真的是太方便了！ 诸多好处，你用了就知道 缺点 专业版不免费，需要支付一定的费用。之前说了那么多的好处，提供很多便利，也可以说是人家靠这些吃饭的，付钱是肯定的！ 去官网看了下，199美刀，按目前1美元~=7.x元人民币的汇率来看，每年大约需要支付1400元左右的费用！ 软件安装和启动时，要占用大量CPU资源和(运行)内存空间！没其他意思，处理器不行或运行空间不够的话，要么机器太老，建议不要安装！否则运行时，就是考验你忍耐度的时候了！卡顿也是正常！ 使用时，你在找找吧。我觉得就以上两个明显一点 对于Microsoft Visual Studio 优点 大部分版本免费，专业版也须付费(同上一个)。它是基本是各大编译器(IDE)票选网站上第一的位置，用户使用还不错。 提供大部分的开发环境，开袋即食。只要你选好了要开发的语言或项目，里面它会给你配置好！ 微软Microsoft自家产品，对Windows本身很友好。毕竟是一家人，该关照的地方不会用太大问题。我可没说JetBrains不好啊！ 缺点 软件安装时体积庞大，占存储空间。官网新版本是一个在线安装器，你等它下载完，让你选安装选项时，你选了太多的选项，体积的真的吓人。一次下载使用时，我完成基本自己使用配置后，体积竟达6个G，太吓人了 可供选择很多的编程项目和语言，不太适合做微软家以外的东西(笔者自己观点)。 官网截图 绝大部分是Windows自己的相关开发，笔者更认为是更适合是Windows自己的编译器，其他只是它附带的。。。。。 对于Visual Studio Code 优点 体积较小(相对前两者)，不占空间。笔者安装上就觉得，体积不大，可以接受。启动速度不错，可以！ 也有丰富的插件库，编程插件看需下载。有微软官方的插件库，也用第三方开发者开发的插件库。看自己需要啥，自己下载配置，自定义。 缺点 不像Pycharm里面基本配置都铺好了，一切从语言开始配置！不配置的话，基本的像一个带皮肤的的记事本。默认是英文界面，可以换成中文。 因为可以自定义，所以你要自定义！你得根据你的编程语言去插件商店里下载对应插件。否则，之后的运行很麻烦。这点新手不太友好，可对过来人讲，这也很适合新手！！！ 综其上所述，字里长短，你也知道笔者使用和推荐的是哪个吧！ 学习教材 笔者同其他绝大部开发者一样，支持和建议阅读和学习官方的说明文档！ python官方文档 当然毕竟是计算机编程，又是国外开发的，自然是英文的。 笔者英语水平也就那样，你们懂的！不过，python团队对全球各地的开发者使用的表达语言不同，提供了其他的语言，包括我们的汉语。 进行如下设置 结果 换成中文啦。 但在这里要提醒大家，如果你是初学者，英语水平那啥，可以先看看中文进行学习，尽量去读英文版的。毕竟两种语言的表示还是会有一些区别；如果你的英语水平还可以，那更要去看多看英文文档，养成这样的好习惯，这对以后的代码快速学习和理解会更快，更纯粹！ 相关权威书籍 这里笔者不一一举例子了。如果你要看书学习的话，建议去看一些知名的国内外出版社或知名的IT人员出版的书。这对学习内容有权威保障，可以放心学。但，还是建议看官方文档吧。毕竟，很多书是依据和参考官网来写的。在源头学，更纯粹，更直接。 这里提供一个python官方说明文档 多格式下载 相关视频或资料 笔者在这里强调，网上视频有很多，但其真伪性和全面性难以保证！如果有需要，建议去比较靠谱的网课网站，教程网，有一定权威性，观看学习！ 笔者在这里跟大家保证，本人所发布的教程文章，因个人的能力和精力有限，一个天天不知道在忙啥的大学党，将尽自己的努力，尽量保证所发布的文章内容准确无误，内容全面！若有错误之处或疑问的地方，请留下你的评论或发送消息至我的邮箱，笔者尽可能会回复相关问题和疑点，感谢理解！ 一些想说的话这是笔者的第二篇文章，更新时间长了些。因初次写编程类的教程，不太熟悉，可能与其他大神的文章相比差很多。希望大家在阅读学习的时候，发现错误或有异议的地方，请多多海涵！我会及时处理和回复！也希望大家能给我些建议，我会考虑后加入到博文里！再次感谢你能访问这个网站和这篇博文！","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"python","slug":"python","permalink":"http://123.56.84.132/public/tags/python/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"（四）Linux守护进程和控制服务","slug":"17","date":"2020-01-31T07:08:29.000Z","updated":"2020-03-06T05:38:55.385Z","comments":true,"path":"2020/01/31/17/","link":"","permalink":"http://123.56.84.132/public/2020/01/31/17/","excerpt":"","text":"守护进程和控制服务 守护进程和控制服务 systemd简介 systemctl简介 查询服务状态 控制系统服务 停止服务并检查服务状态 启动服务并检查服务状态 重启服务实现对服务的停止和启动 发出指令使服务在不停止或重启的情况下重新加载其配置文件] 屏蔽系统服务] 使守护进程在系统启动时自动启动和停止 systemd简介Linux系统和服务进程由systemd系统和服务管理器进行管理，它提供了一种方式可以在启动时和运行中的系统上激活系统资源、Web守护进程和其他进程。 一般情况下，守护进程在系统启动时自动开启并持续维护服务运行，直到服务器关机或手动停止。通常来说，守护进程的进程名以d命名结尾。 systemctl简介systemctl命令用于管理各种类型的systemd对象，他们称之为单元。使用systemctl命令可以对单元进行状态的管理，比如运行、停止运行、设置为开机启动等。 比较重要的一个单元类型是服务单元，服务单元通常的拓展名为.service，代表系统服务。这种单元用于启动经常访问的守护进程，如NginxWeb服务器。还有其他单元类型，如socket套接字单元、path路径单元等。 查询服务状态使用systemctl status name[.type]来查询服务状态。如果未提供单元类型(type)，则默认为service服务单元。(如果该服务单元存在的话~) systemctl status sshd.service #查看ssh服务器守护进程的状态 ● sshd.service - OpenSSH server daemon Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled) Active: active (running) since Fri 2020-01-31 10:38:57 CST; 3h 15min ago Docs: man:sshd(8) man:sshd_config(5) Main PID: 1572 (sshd) Tasks: 1 (limit: 49169) Memory: 7.7M CGroup: /system.slice/sshd.service └─1572 /usr/sbin/sshd -D -oCiphers=aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256-ctr,aes256-cbc,aes128-gcm@openssh.com,aes128-ctr,aes128-cbc -oMACs=hmac-sh&gt; Jan 31 11:32:15 centos8 sshd[4221]: Accepted password for yourname from 192.168.1.157 port 44876 ssh2 Jan 31 11:32:15 centos8 sshd[4221]: pam_unix(sshd:session): session opened for user yourname by (uid=0) Jan 31 11:32:27 centos8 sshd[4307]: Accepted password for yourname from 192.168.1.157 port 44900 ssh2 在上面的状态中找到几个关键词： 关键词 描述 loaded 单元配置文件已受理 enabled 在系统启动时自动运行 disabled 在启动运行时不会自动启动 active(running) 正在通过一个或多个进程持续运行中 active(exited) 已经成功完成一次性的任务并结束守护 active(waiting) 运行中，但正在等待事件发生… inactive 进程没有运行 控制系统服务停止服务并检查服务状态systemctl stop sshd.service systemctl status sshd.service 启动服务并检查服务状态systemctl start sshd.service systemctl status sshd.service 重启服务实现对服务的停止和启动systemctl restart sshd.service systemctl status sshd.service 发出指令使服务在不停止或重启的情况下重新加载其配置文件如果对服务的配置文件进行了修改，不想对服务关闭影响业务的情况下使用reload选项来让服务对配置文件重新读取并加载。 systemctl reload sshd.service systemctl status sshd.service 屏蔽系统服务有些时候，系统中可能安装了相互冲突的服务，比如防火墙iptables与firewalld。为了防止管理员意外的启动两个服务可以将服务进行屏蔽。屏蔽服务将在配置文件目录中创建软连接，将其服务指向/dev/null设备文件，这样不小心启动了冲突的服务也不会出现有什么刺激的事情发生！ systemctl mask sshd.service # 屏蔽ssh服务器守护进程 Created symlink /etc/systemd/system/sshd.service → /dev/null. systemctl start sshd.service # 屏蔽后尝试启动 Failed to start sshd.service: Unit sshd.service is masked. # 提示服务单元被屏蔽，无法启动。 systemctl unmask sshd.service # 解除屏蔽ssh服务器守护进程 Removed /etc/systemd/system/sshd.service. 使守护进程在系统启动时自动启动和停止在使用systemctl对一个守护进程启动或停止，不能保证其下一次系统运行时也是启动或停止的状态。当相应的systemd配置目录中创建了软连接时，服务会随着系统启动的时候启动。软连接可以通过systemctl命令创建和删除。 首先要查看服务状态，如果关键词出现disabled证明这个服务在系统启动时不会随着系统一起启动，否则相反。 systemctl enable sshd.service # 设置软连接，使得该服务随系统启动时启动。 systemctl is-enabled sshd.service # 验证状态，返回为`enabled`为开启自动启动，`disabled`为不会开机自动启动。 enabled systemctl disable sshd.service # 删除软连接，使得该服务不会随系统启动时启动。 systemctl is-enabled sshd.service # 验证状态，返回为`enabled`为开启自动启动，`disabled`为不会开机自动启动。 disabled","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"linux","slug":"linux","permalink":"http://123.56.84.132/public/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"hanwckf 的Mi-R3G 路由器固件","slug":"21","date":"2020-01-31T02:50:25.000Z","updated":"2020-03-06T05:38:55.500Z","comments":true,"path":"2020/01/31/21/","link":"","permalink":"http://123.56.84.132/public/2020/01/31/21/","excerpt":"","text":"下载地址 v2019-11-26：点此下载 更新日志 v2019-11-26 所有USB机型启用hdparm和parted 所有机型启用openssl_ec 添加CONFIG_FIRMWARE_WEBUI_HIDE_VPN选项，可以隐藏webui中的vpn页面 删去mt7615驱动的两个无关紧要的日志输出 （#159 #174） 应用PROMETHEUS的r8152补丁 mt7628：修复cryptodev支持 napt66：修复pppoe拨号时WAN接口名识别错误的问题 DIR-878：启用ss minieap/njit-client：修复几个编译时警告 添加专属banner：","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}]},{"title":"gcc编译步骤","slug":"19","date":"2020-01-30T13:25:40.000Z","updated":"2020-03-06T05:38:55.430Z","comments":true,"path":"2020/01/30/19/","link":"","permalink":"http://123.56.84.132/public/2020/01/30/19/","excerpt":"","text":"一步到位：gcc hello.c 这条命令隐含执行了 （1）预处理 （2）编译 （3）汇编 （4）链接 这里未指定输出文件，默认输出为a.out gcc编译C源码有四个步骤： 预处理 —-&gt; 编译 —-&gt; 汇编 —-&gt; 链接 现在我们就用gcc的命令选项来逐个剖析gcc过程 1)预处理(Pre-processing)在该阶段，编译器将C源代码中的包含的头文件如stdio.h添加进来 参数：”-E” 用法：gcc -E hello.c -o hello.i 作用：将hello.c预处理输出hello.i文件。 2)编译(Compiling)第二步进行的是编译阶段，在这个阶段中，gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。 参数：”-S” 用法：gcc –S hello.i –o hello.s 作用：将预处理输出文件hello.i汇编成hello.s文件。 3)汇编(Assembling)汇编阶段是把编译阶段生成的”.s”文件转成二进制目标代码“.o”文件 参数：“-c” 用法：gcc –c hello.s –o hello.o 作用：将汇编输出文件hello.s编译输出hello.o文件。 4)链接(Link)在成功编译之后，就进入了链接阶段。 用法：gcc hello.o –o hello 作用：将编译输出文件hello.o链接成最终可执行文件hello。 运行该可执行文件，出现正确的结果如下。 &gt;&gt;&gt; ./hello Hello World! 简单赘述一下gcc和g++的区别 - gcc与g++都可以编译c代码与c++代码。但是：后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；后缀为.cpp的，两者都会认为是C++程序。 - 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接 - 编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"C++","slug":"代码学习/C","permalink":"http://123.56.84.132/public/categories/代码学习/C/"}],"tags":[],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"C++","slug":"代码学习/C","permalink":"http://123.56.84.132/public/categories/代码学习/C/"}]},{"title":"C和C++后缀区别","slug":"1","date":"2020-01-30T13:09:40.000Z","updated":"2020-03-06T05:38:55.201Z","comments":true,"path":"2020/01/30/1/","link":"","permalink":"http://123.56.84.132/public/2020/01/30/1/","excerpt":"","text":"C 头文件: .h 源文件: .c CPP 头文件后缀名： .h, .hpp, .hxx 源文件后缀名：.cpp, .cc, .cxx, .C .c++ .h和.hpp的区别是：.h里面只有声明，没有实现，而.hpp里声明实现都有，后者可以减少.cpp的数量，适合用来编写公用的开源库。 inl 文件是内联函数的源文件。内联函数通常在c++头文件中实现，但有的时候内联函数较多或者出于一些别的考虑（使头文件看起来更简洁等），往往会将这部分具体定义的代码添加到INL文件中，然后在该头文件的末尾将其用#include引入。由此也可以看到inl文件的例外一个用法的影子——模板函数、模板类的定义代码的存放。","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"C++","slug":"代码学习/C","permalink":"http://123.56.84.132/public/categories/代码学习/C/"}],"tags":[],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"C++","slug":"代码学习/C","permalink":"http://123.56.84.132/public/categories/代码学习/C/"}]},{"title":"（四）运算符和表达式（上）","slug":"9","date":"2020-01-29T12:55:29.000Z","updated":"2020-03-06T05:38:56.144Z","comments":true,"path":"2020/01/29/9/","link":"","permalink":"http://123.56.84.132/public/2020/01/29/9/","excerpt":"","text":"这次所讲的内容很杂很繁琐，但是不难理解 因为内容多，分为（上）和（下）去讲 今天要讲三件事 1.算术运算 2.关系运算 3.逻辑运算 算术运算1.使用%运算符：-取余运算（%）意味着取余数，可适用于整数、char类型。 2.使用“++”“–”运算符:·Java的自增运算符和自减运算符继承自C++，可以使变量的值加1或者减1，但其写在变量前和变量后有不同的效果： -如果写在变量前表示在使用这个变量之前加1减1 -如果写在这个变量之后表示这个变量先使用，在加1减1 这里列举了三个案例： //算数：+，—，*，/，++，-- //++,--单独使用，在前在后无差别 //在使用时，有差别的： // ++在前，先运算(自加)，再使用 // ++在后，先使用，再运算 int n=5,m=5; n++; ++m; System.out.println(n); System.out.println(m); int a=5,b=5; System.out.println(a++);//5 System.out.println(++b);//6*/ int c=5; int d=++c; System.out.println(c);//6 System.out.println(d);//6 技巧：“谁近先看谁”，如果先看到的变量，那么先使用，再运算，如果先看到++或者–，那么先自加自减，然后再使用。 关系运算符关系运算符用于判断数据之间的大小关系，包括大于（&gt;）、小于(&lt;)、大于等于(&gt;=)、小于等于(&lt;=)、等于(==)、不等于(!=)六个运算符。关系运算的结果为boolean类型，如果关系成立为true，否则为false //关系运算符：&gt;、&lt;、&gt;=、&lt;=、==、!= int a=5,b=8,c=5; boolean b1=a&gt;b; System.out.println(b1);//false System.out.println(b&gt;c); //true 逻辑运算 逻辑运算·逻辑运算建立在关系运算的基础之上，逻辑运算符包括：与（&amp;&amp;）、或（||）、非（！） 使用”&amp;&amp;”运算符:两个boolean变量参与&amp;&amp;运算时，只有当两个变量均为true时，运算结果才为true，否则为false 使用”||”运算符：·两个boolean变量参与||运算时，当两个变量有一个为true时，结果为true，只有当两个变量均为false时，结果为false 使用”！”运算符：·！运算符相对简单，只会有一个boolean变量参与运算，运算的值与改变了相反，变量为true时结果为false，变量为false时结果为true /逻辑运算符：&amp;&amp;、||、！ int a=100,b=200; boolean b1=a&gt;10&amp;&amp;b&lt;10; System.out.println(b1);//false System.out.println(a&gt;b||a&lt;b);//true System.out.println(!(a&gt;b));//true 关于”短路逻辑“的问题Java逻辑运算遵循“短路逻辑”的原则： -对于&amp;&amp;，当第一个操作数为false时，将不会判断第二个操作数，因为此时无论第二个操作数为何，最后的运算结果一定是false； -对于||，当第一个操作数为true时，将不会判断第二个操作数，因为此时无论第二个操作数为何，最后的运算结果一定是true； 彩蛋这次让我们一起来做接触java后的第一个案例 得分是否及格判断程序 要求输入得分，判断是否优秀 优秀（85-100） 从目前为止到现在，这是第一回碰上要手动输入得分的地方，那么在Java中如何进行输入操作呢？ 分四步： 第一步：impot java.util.Scanner; 第二步：Scanner scan=new Scanner(System.in); 第三步：scan.nextInt(); 第四步：scan.close();（可有可无） 那么，该如何将这四步完美的写进代码中呢？请看下面代码： //分数判断程序 import java.util.Scanner;//第一步 public class Age { public static void main(String[] atge){ Scanner scan=new Scanner(System.in);//第二步 System.out.println(&quot;请输入得分&quot;); int grade=scan.nextInt();//第三步 boolean b1 = grade&gt;=85&amp;&amp;grade&lt;100; System.out.println(b1); scan.close();//第四步,可写可不写 } } 那么今天就这样啦！一定要自己动手敲代码，才会有提高！","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://123.56.84.132/public/tags/java/"},{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}]},{"title":"（三）Linux查找系统中的文件","slug":"12","date":"2020-01-29T03:13:06.000Z","updated":"2020-03-06T05:38:55.264Z","comments":true,"path":"2020/01/29/12/","link":"","permalink":"http://123.56.84.132/public/2020/01/29/12/","excerpt":"","text":"查找系统中的文件使用locate和find即可实现在挂载的文件系统中搜索文件。 查找系统中的文件 locate与find介绍 locate命令 find命令 根据名称查找文件locate 常用选项 使用find查找文件 常用选项 -name选项： -iname选项： -user和-group选项： locate与find介绍locate命令locate命令是搜索预先生成的数据库中的文件名或文件路径，这份数据库正常是由cron计划任务每天自动更新，数据库默认位置在： Ubuntu /var/cache/locate/locatedb RHEL/var/lib/mlocate/mlocate.db 如果没有该数据库那么需要手动生成，使用管理员用户执行命令updatedb即可自动生成。 find命令find是爬取整个文件系统来实时的搜索文件系统，所以搜索比较慢。如果是刚刚添加的文件使用find才能搜索到，因为locate需要等待下一次更新数据库后才能搜索的到新添加的文件。 根据名称查找文件locatelocate命令根据locatedb数据库文件进行搜索并返回文件名和路径，通过数据库查询搜索会非常的快，因此只在你眨眼的功夫你想要搜索的文件路径或名称就显示到你的眼前了。 以普通用户身份搜索条目时，调用locate搜索的用户必须对包含所匹配元素的目录树有读取的权限，否则是不会返回结果的。 在该账户有权限读取的目录树中，搜索名称或路径包含passwd的文件。 locate passwd # 搜索passwd /etc/cron.daily/passwd /etc/pam.d/chpasswd /etc/pam.d/passwd /etc/passwd /etc/passwd- /etc/security/opasswd /etc/sudoers.d/010_pi-nopasswd ... 即使文件名或目录包含匹配到的搜索，也会返回结果。 locate image # 搜索image /home/pi/Tools/fuzzDicts/images /home/pi/Tools/fuzzDicts/images/README.MD /home/pi/Tools/fuzzDicts/images/api.jpg /home/pi/Tools/fuzzDicts/images/directory.jpg /home/pi/Tools/fuzzDicts/images/fileExt.png /home/pi/Tools/fuzzDicts/images/parameter.jpg /home/pi/Tools/fuzzDicts/images/password.jpg /home/pi/Tools/fuzzDicts/images/sql.jpg 常用选项-i选项：不区分大小写，对所有大小写字母的组合都会进行匹配。 -l选项：限制locate搜索结果的返回数量，实例如下，限制结果仅返回5个匹配项。 locate -l 5 v2ray # 搜索`v2ray`并限制结果仅返回5个匹配项。 /etc/systemd/system/multi-user.target.wants/v2ray.service /etc/systemd/system/v2ray.service /etc/v2ray /etc/v2ray/config.json /home/pi/disk/v2ray_client.json 使用find查找文件find命令在本地文件系统中实时的搜索，查找符合匹配条件的文件。使用find命令要求当前用户对要查看内容的目录有读取和执行的权限。 find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression] find命令有很多选项，使用这些选啊ing可以对文件进行精确的搜索，比如通过时间戳、文件大小、修改时间等其他文件特性任意组合对文件进行查找和筛选。 常用选项-name选项：后面跟上文件名可以查找匹配所给的文件名的文件，并返回该文件的绝对路径。例如若要在文件系统的/根目录下搜索名为ssh_host_rsa_key的文件： sudo find / -name &quot;ssh_host_rsa_key&quot; /etc/ssh/ssh_host_rsa_key 还可以使用通配符搜索文件。使用通配符搜索时一定要将文件名用引号引起，防止当前使用的终端对通配符进行解析。 sudo find / -name &quot;*.conf&quot; /lib/modprobe.d/systemd.conf /lib/modprobe.d/aliases.conf /lib/modprobe.d/fbdev-blacklist.conf /lib/systemd/system/rc-local.service.d/debian.conf /lib/systemd/system/systemd-resolved.service.d/resolvconf.conf /lib/systemd/system/systemd-timesyncd.service.d/disable-with-time-daemon.conf /lib/systemd/system/user-.slice.d/10-defaults.conf /lib/systemd/resolv.conf ... -iname选项：使用方式和-name选项一致，但使用-iname选项搜索时不区分大小写。并且同样支持通配符搜索文件。 -user和-group选项：可以通过文件的所有者和所有组来对文件进行搜索，-uid和-gid也是用来限定文件所有权的选项。并且可以与其他选项如-name搭配使用。例如搜索用户为www所属的全部文件： find / -user www # 在根目录下开始搜索文件所有者是`www`的所有文件及目录。 /home/wwwroot/mail.yeefire.com /home/wwwroot/blog.yeefire.com /home/wwwroot/blog.yeefire.com/log.txt /home/wwwroot/blog.yeefire.com/var /home/wwwroot/blog.yeefire.com/var/Upgrade.php /home/wwwroot/blog.yeefire.com/var/Typecho ... sudo find / -user www -name &quot;*yeefire.com&quot; /home/wwwroot/mail.yeefire.com /home/wwwroot/blog.yeefire.com","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"linux","slug":"linux","permalink":"http://123.56.84.132/public/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"(二)Linux存储设备的挂载及识别","slug":"4","date":"2020-01-28T04:22:27.000Z","updated":"2020-03-06T05:38:56.019Z","comments":true,"path":"2020/01/28/4/","link":"","permalink":"http://123.56.84.132/public/2020/01/28/4/","excerpt":"","text":"存储设备的挂载及识别 存储设备的挂载及识别 存储挂载的概念 查找存储设备 存储的挂载 解除挂载 实现存储设备开机自动挂载 存储挂载的概念将驻留在物理磁盘或虚拟镜像上的文件系统添加到现有目录树的过程称为挂载。其中挂载到系统的目录称为挂载点。 存储设备由一个特殊文件类型表示，称为块设备。块设备存储在/dev目录下。在RHEL系操作系统中，检测到的第一个SCSI、SATA或USB存储设备叫sda,块设备在/dev/sda，第二个是sdb以此类推。该名称代表整个存储设备。若要挂载某一分区，那么在/dev/sda上的第一个分区叫sda1、第二个分区叫sda2以此类推。 虚拟机中的磁盘驱动器是例外情况，通常显示为/dev/vd(x)或/dev/xvd(x) 查找存储设备fdisk -l显示磁盘分区信息 df -h显示已经挂载的文件系统的信息。 lsblk树状图显示磁盘分区以及挂载信息 存储的挂载常用mount &lt;operation&gt; &lt;mountpoint&gt;命令挂载存储设备，这种手动的挂载都是临时的，重启便失效。 参数1(operation):指定要挂载的文件系统 参数2(mountpoint):指定将要挂载的文件系统挂载到本机的目标目录(挂载点) 从发现存储设备到挂载存储设备的过程例子如下： lsblk # 使用命令`lsblk`发现存储设备以及分区 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1.8T 0 disk ├─sda1 8:1 0 200M 0 part └─sda2 8:2 0 1.8T 0 part /home/pi/disk sdb 8:16 1 29G 0 disk └─sdb1 8:17 1 29G 0 part mmcblk0 179:0 0 119.3G 0 disk ├─mmcblk0p1 179:1 0 256M 0 part /boot └─mmcblk0p2 179:2 0 119G 0 part / # 找到了想要挂载的磁盘驱动器`sdb`，现在将这个驱动器的第一个分区`sdb1`挂载到本机的`/mnt/mydisk`目录下 mkdir /mnt/mydisk # 创建目录作为挂载点 mount /dev/sdb1 /mnt/mydisk # 将`/dev/sdb1`挂载到`/mnt/mydisk`目录上。 如果提示权限不足，请使用root权限操作。 现在已经将/dev/sdb1磁盘分区挂载到了系统的/mnt/mydisk挂载点上。 检查是否已经成功地挂载，可以使用df -h或lsblk。 解除挂载使用umount &lt;mountpoint&gt;来解除对文件系统的挂载。 参数1(mountpoint):要解除挂载的挂载点 比如我们刚刚将/dev/sdb1挂载到了系统的/mnt/mydisk挂载点上，使用umount /mnt/mydisk即可解除挂载。 实现存储设备开机自动挂载使用mount的挂载只是临时的，重启后就失效了，如果需要继续使用存储设备就要重新挂载，相当的麻烦。 实现开机自动挂载需要修改系统的/etc/fstab配置文件，在这个配置文件中添加一些要挂载存储设备的信息。 对/etc/fstab修改比较危险，如果没有一定把握请不要使用这种方式挂载存储设备，如果配置有误，系统重启后将进入恢复模式无法正常的开机。 fstab支持两种配置方式： * 使用UUID配置(推荐。只要不格式化，UUID不会改变) * 使用存储设备的块设备文件/dev/sdb1(如果设备的顺序有变化或者向系统中添加了其他的设备，设备块设备文件路径会有变化导致系统无法正常启动) 使用lsblk -f列出系统中发现的现有分区以及文件系统的UUID和该分区文件系统的格式等信息。 lsblk -f NAME FSTYPE LABEL UUID FSAVAIL FSUSE% MOUNTPOINT sda ├─sda1 vfat EFI 67E3-17ED └─sda2 exfat HD 5D31-C4ED 1T 44% /home/pi/disk sdb └─sdb1 vfat ESD-ISO F0ED-593A 28.9G 0% /mnt/mydisk mmcblk0 ├─mmcblk0p1 vfat boot 5203-DB74 199M 21% /boot └─mmcblk0p2 ext4 rootfs 2ab3f8e1-7dc6-43f5-b0db-dd5759d51d4e 99.8G 11% / 可以看到/dev/sdb1文件系统的格式为vfat，UUID为F0ED-593A。 切换到root用户，编辑/etc/fstab文件，并按照fstab文件原有的格式添加到文件末尾行。 UUID=F0ED-593A /mnt/mydisk vfat defaults 0 0 使用mount -a对fstab配置文件中的全部磁盘分区以此进行挂载，如果没有报错，则配置文件编写正确。 使用df -h检查挂载点是否正确。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"linux","slug":"linux","permalink":"http://123.56.84.132/public/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"（一） Linux文件系统和目录","slug":"10","date":"2020-01-27T12:30:34.000Z","updated":"2020-03-06T05:38:55.171Z","comments":true,"path":"2020/01/27/10/","link":"","permalink":"http://123.56.84.132/public/2020/01/27/10/","excerpt":"","text":"目标 1.识别Linux的重要目录的用途 2.使用绝对和相对路径名称指定文件 3.显示文件目录列表 4.使用命令行实用工具创建、复制、移动和删除文件与目录 5.查找文件或目录 一、 文件系统层次结构 目标：了解基本的文件系统布局、组织、以及重要文件类型的位置 /usr #安装的软件、共享的库，包括文件和静态只读程序数据。 /usr/bin #用户命令 /usr/sbin #系统管理命令 /usr/local #本地自定义软件 /etc #此系统的配置文件 /var #此系统的可变数据，动态变化的文件（如：数据库、缓存目录、日志文件、打印机后台处理文档和网站内容等） /home #普通用户存储个人数据和配置文件的主目录 /root #超级用户root的主目录 /tmp #供临时文件使用的可写空间，10天有效。 /var/tmp #30天有效。 /boot #启动过程所需要的文件 /dev #设备文件。 二、目录的操作命令 ls/ll, cd, mkdir/mkdir -p, pwd, cp -r, mv, rm -r ls : 显示目录文件列表 ls -l 或ll : 长格式显示…. pwd : 显示当前所在目录、或路径 cd : 改变当前目录，或路径 mkdir : 创建目录 mkdir -p : 创建一个目录树 cp -r : 复制目录 cp: 复制： cp file1 file2 //file1和file2是带全路径 mv : 移动 rm -r : 删除目录 三、文件的操作命令 touch, vi, cat, head, tail, more, less, find touch ：创建一个文件 vi或vim ：文本编辑器 ——-显示文件内容的命令—– cat：在屏幕上显示文件内容从前到后滚屏 tail：只显示文件后面n行的内容 head: 显示文件头开始的n行 more: 分屏显示文件内容 less: 分屏显示….，但可以回滚显示。 cp: 复制： cp file1 file2 //file1和file2是带全路径 mv: 移动 mv file1 file2 rm: 删除 rm filename find: find -name find -user grep:搜索关键字 输出重定向: &gt; :覆盖原有文件并写入 &gt;&gt; :在原有文件基础上追加写入 链接ln ln -s 通配符的使用 ？ 代替任意1个字符串 ？代替任意1个字符 练习任务 任务1: 在/home目录下创建user1 和user2两个目录 将user1目录移动到user2目录下 mv user1 user2 将user1复制到/home目录下 删除user2目录 任务2： 在user1目录下创建两个空文件text1和text2 将系统日志文件message后五行复制到text1中 提示（&gt;:输出重定向。&gt;&gt;:输出重定向，追加的方式输出|：管道 ls /dev | less） 任务3： 在 /home 目录下创建 /home/user 目录，并在该目录下创建文件 test1.txt , test2.txt 并将test2复制到 /home/share/test 目录下，将 /home 目录文件列表详细内容添加到文件 test1.txt 文件中，并编辑 test1.txt 文件删除文件中第2行。然后显示 test1.txt 文件内容。为 test1.txt 在 home 目录下创建一个硬链接文件 test1ln 和一个符号链接文件 test1lns。 任务4： 找出/var/log目录下所有后缀是.log的文件，并将这些文件复制到/home/dustbin目录下，并将/home/dustbin目录删除；然后删除/home/user目录下的test2.txt。 创建目录 创建文件 复制文件 cp filename1 filename2cp filename 路径 * 1. 长格式显示目录文件列表 2. 输出重定向 3. 编辑文件 4. 显示文件内容 5. 创建链接文件 6. 通配符的使用 a. * ——代替任意字符串 b. ？——代表任意1个字符 7. 查找文件 find命令 find 路径 -name 文件名 find 路径 -user 用户名 Ctrl+c 中断执行","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"},{"name":"linux","slug":"linux","permalink":"http://123.56.84.132/public/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"在？还没用Github?","slug":"5","date":"2020-01-23T16:17:56.000Z","updated":"2020-03-06T05:38:56.056Z","comments":true,"path":"2020/01/24/5/","link":"","permalink":"http://123.56.84.132/public/2020/01/24/5/","excerpt":"","text":"关于本文章 临睡之前没忍住戳了下大佬撩闲，果然被大佬顺杆抓住让我也来写东西。 平时我用的好多东西都是停留在“会用”的程度上，真的让我写出一个通俗又到位的教程还挺难的，所以这篇文章中可能有概念把握不好，请留意。 Github大名早有耳闻，为什么要用？ 这个我们要先说下Git是干嘛的。 众所周知Git是“版本控制系统”，作为初学者或许并不能在自己开发的过程中感受到版本控制的好处，但至少在你发现你的思路严重跑偏走进了死胡同的时候，通过版本控制你能很方便的回滚到跑偏之前的那个“版本”，不用一点点拆你写好的东西。而每完成一部分功能就提交一下，也有助于你管理自己的进度。 大型项目也会有上述问题，而且，在多人一同开发软件的时候，同样一份工程文件，每个人在自己电脑上做了不同的操作，当他们将代码合并到一起的时候，谁删了什么，谁加了什么，谁引用的文件被谁做了修改，如果没有个统一的管理办法就会出很多这种问题。 Git就是众多版本控制系统里很优秀而且广泛应用的一个，并且是Github唯一支持的代码库格式。 而为什么是Github？我也不知道Github是怎么发展起来的。只是显而易见，平时做开发经常听到的那些东西，大到spring、vue框架，小到一个Android控件一个数据结构实现，基本上只要是“开源”的东西，都作为一个个公开的Git库被放到Github上了。也就是说，你不仅可以把这些源码下载下来学习和使用，还可以参与开发做贡献（请让我抱大腿），而且种多开源项目你都可以在项目主页上直接找到使用教程和文档，总之一句话：Github全球最大的开源社区。 说回来，本身这就是一个代码托管平台，你自己的项目就可以用Github作为远程代码库来进行管理。那么接下来我们就要说这件事。 正题：从Git入手来使用Github学习Github的过程也是学Git的过程。毕竟是Git-hub。 已经说过了Git是干嘛的，那么我们进一步说几个经常遇到的术语： 1. Repository (库)： 一般来说，一个库也就对应着一个项目，就是存放你代码和版本记录的地方。在Git中，除了在你电脑中会有一份记录你自己操作的本地库，还可以在服务器上有一份远程库用于同步多人的代码。 2. Commit (提交) 将你的修改记录提交到库中，也就是将当前工程内容与库中不一样的部分提交到库里，一次提交也就对应着我们一直说的一个“版本”记录。 3. Branch (分支) 分支是Git一个很重要的内容，对应的还有合并，不同的分支之间的内容不会互相干扰，它的应用场景也很多，比如在大型项目开发的过程中会分出生产版本和测试版本，测试版本自然是和生产版本独立开来，那么他们就可以作为两个分支，在测试分支中完成目标后合并到生产分支。现在我们只需要知道，但当你创建一个git库时，你就自动进入了一个分支，叫“主分支(master branch)”。 4. push (推送) 将当前本地库中的代码推送到远程库。 5. Pull (拉取) 将远程代码库中的内容拉去到本地库。 实践：将自己的Git库上传到Github上 好了，终于到了真正的正题了，其实本来应该直接写这部分的，奈何我磨洋工点的太深。 接下来我们要做的是，将Git应用到我们的一个工程上，然后将本地的Git库推到Github上。在这个例子中，我会用Maven随便搞个工程结构出来（看着舒服），然后在这个工程中创建Git，并做一次提交。最后将这个Git上传到Github上。 那么，安装Git然后再注册个Github账号吧 Git官网下载页：https://git-scm.com/downloads GitHub：https://github.com/ 成功安装了Git之后，我们需要一个小配置，打开Git bash，通过下面两行命令给你自己做一个身份标识，这个信息会存在于你每次提交的版本中，用来标识这个版本属于谁： git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; 效果： 初始化版本库与添加要管理文件首先我们进到项目目录里，右键菜单里有个Git bash here，点击这个就可以直接打开Git bash，并且路径就是当前路径了，不用再手动打。 可以看到打开的路径直接就是我文件路径： (上面这码当我没打) 确认bash已经进入了当前工程目录，我们就可以开始创建Git了： git init //在当前目录初始化git git add . //注意最后的“.”，这个点代表当前目录，这行命令就是将当前整个目录添加到git暂存区 效果： 不要在意底下那堆warning，这是我文件格式有点小问题，不影响操作。 提交一个版本使用commit命令提交版本 $ git commit -m &quot;message&quot; 其中，-m参数表示message，也就是为这个版本添加一条注释消息，其作用就是“注释”。 效果： 可以看到输出信息，命令执行后我们将文件提交到了master分支,版本id d839f16,并且注释了“初始化工作目录”。 同步到Github上去！首先在github上创建一个空项目，命名随意。 创建完成后进入项目默认页面，你会看到页面已经给出了该远程git库的链接，我们要用的就是这个链接。 而再往下翻你还能看到他已经给你如何从已存在的项目push上来的方法了。。就是这样。 git remote add origin https://github.com/Pablo-Zen/Testproj.git git push -u origin master 效果： 现在再刷新我们刚才那个页面，默认给的链接和方法提示都没了，变成了我们工程目录的样子。 然而回看我们的工程目录，很明显少了个src文件夹： 这并不是问题，其实在commit那条命令执行的截图里就可以看到，输出的都是文件，而我的目录里src中还是两个文件夹，并没有实际的文件，所以也就没被管理。 至此，我们完成了本地git库上传github的操作。 小结 第一次写教程感觉自己太墨迹了，其实看下来一遍就能知道，这个操作没什么内容，一共就那么几个命令，可以说是git最基本的基本吧。 希望以后再写东西的时候，能切重点高效一些。 图片马赛克就当我没打吧。","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}]},{"title":"（三）Java的数据类型","slug":"23","date":"2020-01-22T13:02:29.000Z","updated":"2020-03-06T05:38:55.557Z","comments":true,"path":"2020/01/22/23/","link":"","permalink":"http://123.56.84.132/public/2020/01/22/23/","excerpt":"","text":"基本类型int、long、double、char、boolean(存储逻辑变量（true、false）) 整型整型分为int型和long型 1.int型 表示整数型，int a=5； 思考： 为什么换了100的位置，结果就发生了变化？ int a=72； int b=21； int percent =b/a*100; System.out.println(percent+“%”)； //这里的percent为0% int a=72； int b=21； int percent =100*b/a; System.out.println(percent+“%”)； //这里的percent为29% 答案：因为int计算的都是整型，所以如果先b/a的话得数是0.如果先乘以100的话，那就可以进行计算了 整数运算的溢出： 两个整数进行运算的时候，结果可能会超过整数范围并溢出，正数过大产生的溢出结果为负数，相反，负数过大产生的溢出结果为正数。 public class DataTypeDemo { public static void main(String[] args){ //int:整型 int a=8;//88为直接量，java默认int型 //超过int范围了，所以报错 //int b=10000000000; //小数无条件舍去 int c=5/3; System.out.println(c); //溢出（是需要避免的） int m=2147483647;//m为int的最大值 m=m+1;//在最大值基础之上加1---溢出 System.out.println(m); } 结果为m=-2147483647 long型如果int 类型的范围不够，可以使用long型。 表示范围：-9223372036854775808-9223372036854775808 如果要表示long直接量，需要以L或者l结尾 long a=10000L； 浮点型主要讲double型 ·浮点数，大多数场合使用double表示浮点数，因为double的精度值是float的两倍。 //运算性以大类型作为最终类型 int a=5/2; double b=5/2; double c=5.0/2; System.out.println(a);//2 System.out.println(b);//2.0 System.out.println(c);//2.5 若表示flaot类型的直接量，需要加f或者F后缀 例如： float a=3.14f； double运算时会出现舍入误差： double a=3.0； double b=2.9； System.out.println(a-b); //输出的结果是0.1000000000009 char类型·字符直接量：‘中’的形式，‘a’，占两个字符 对char型变量赋值： 注：一个char型变量只能存储一个字符 在对char型变量赋值时，可以采用如下三种方式： -字符直接量：形如‘A’，变量中实际存储的是该字符的Unicode编码 -整型直接量，：范围在0~65535之间的整数，变量中实际存储的即该整数值，但表示的是该整数所对应的的Unicode字符。 -Unicode形式： char c=‘A’； char c=65; 使用转义字符：含义 ‘\\n’ 表示回车符 ‘\\r’ 表示换行符 ‘\\‘’ 表示单引号 ‘\\‘’’ 表示双引号（”） ‘\\‘ 表示反斜杠（\\） boolean型使用boolean变量进行关系运算： ·boolean类型适用于逻辑运算，表示某个条件是否成立。一般用于程序的流程控制 ·boolean类型只允许取值true或false，true表示条件成立而false表示条件不成立 ·boolean型变量经常用于存储关系运算的结果，所谓关系运算就是比较两个变量的大小相等等关系 //boolean型，占1个字节 int age=18; boolean isChild=age&lt;16;//isChild的值为false System.out.println(isChild); boolean running=true; boolean closed=false; 数据类型转换分为两类： 1.自动类型转换 2.强制类型转换 int a=60； long b=a//自动类型转换 小--大 int c=（int）b；//强制类型转换 大--小 byte、char、short转换为int ·byte、char、short三种类型的实际存储的数据都是整数，在实际使用中遵循如下规则： ·int量可以直接赋值给byte、char和short 例如：byte a=55；char c=97; ·byte、char、short只要参与运算，则一律转为int型 byte b1=5； byte b2=6； byte b3 =b1+b2；//错误 应改为： byte b3=(byte)(b1+b2); 从小到大的顺序：byte&lt;short&lt;int &lt;long&lt;float&lt;double 小结：数据类型： int ：55 long：55L double:55.0 char:’a’ boolean:true和false 类型间转换","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://123.56.84.132/public/tags/java/"},{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}]},{"title":"基于github的CDN：jsDelivr","slug":"6","date":"2020-01-21T03:31:57.000Z","updated":"2020-03-06T05:38:56.063Z","comments":true,"path":"2020/01/21/6/","link":"","permalink":"http://123.56.84.132/public/2020/01/21/6/","excerpt":"","text":"前言 JSDelivr 能够集成 Github、NPM 资源，只需要通过符合 JSDelivr 规则的 URL 引用，即可直接使用 Github 中的资源。也可以使用发布到 NPM 的资源，这就是生产力。 官方网站 https://www.jsdelivr.com/ 使用方法 新建Github仓库 克隆Github仓库到本地 执行git clone命令 git clone https://github.com/xbclub/CDN.git #链接要替换成你自己的仓库链接 ![cmd-git-clone](https://cdn.jsdelivr.net/gh/xbclub/CDN/wp-content/uploads/2020/01/Annotation-2020-01-21-110713.jpg &quot;cmd-git-clone&quot;) 上传资源 将需要上传的资源放入clone下来的文件夹中，执行以下命令： git add . //添加所有文件到暂存区git commit -m ‘第一次提交’ //把文件提交到仓库git push //推送至远程仓库 如图 ![git commit](https://cdn.jsdelivr.net/gh/xbclub/CDN/wp-content/uploads/2020/01/Annotation-2020-01-21-111553.jpg &quot;git commit&quot;) ![git push](https://cdn.jsdelivr.net/gh/xbclub/CDN/wp-content/uploads/2020/01/Annotation-2020-01-21-111736.jpg &quot;git push&quot;) 发布仓库 通过jsDelivr引用资源 使用方法： https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如： https://cdn.jsdelivr.net/gh/xbclub/CDN@0.1/manifest/gallary/1153196917.jpg 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： https://cdn.jsdelivr.net/gh/xbclub/CDN@master/manifest/gallary/1153196917.jpg https://cdn.jsdelivr.net/gh/xbclub/CDN@master/manifest/","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"实用技巧","slug":"奇思妙想/实用技巧","permalink":"http://123.56.84.132/public/categories/奇思妙想/实用技巧/"}]},{"title":"（一）安装python","slug":"28","date":"2020-01-20T17:07:40.000Z","updated":"2020-03-06T05:38:55.706Z","comments":true,"path":"2020/01/21/28/","link":"","permalink":"http://123.56.84.132/public/2020/01/21/28/","excerpt":"","text":"python入门(安装篇)这篇博客将带领大家一起学习python编程语言。这里以Windows环境，记事本为例 开发环境笔者的开发环境为 python for Windows 3.8.1 x64 Windows 10 专业版 1909 版本为10.0.18363.418 准备条件(下载安装) 从python官方网站https://www.python.org下载最新的python 3安装包 在python官网界面找到Downloads—Windows—Download for Windows—3.8.1。点击按钮开始下载! 注意：这是默认下载32位版本，根据自己操作系统的处理器类型经行python版本的选择 点击Windows，进入https://www.python.org/downloads/windows/进行Windows的版本选择 在这里，笔者选择Download Windows x86-64 executable installer x86-64位的可执行安装器 注意，因为python官网的服务器在国外，下载速度会慢些，需要耐心等待。提示：如果你在本校校内，可使用42Team的42下载站，http://172.24.4.199，搜索python 进行高速下载！ 下载的安装包如下 以管理员身份运行它 打开页面如下 在这里，我们选择 Install Now 和Add Python 3.8 to PATH Customize installation 是用户自定义安装，有其他需求的开发者可以用这个进行自定义安装 注意：在python安装界面里，直接勾选Add Python 3.8 to PATH 可在安装过程中，直接将python添加至系统环境变量中。若未勾选，可手动添加python环境至系统环境变量中或可在安装结束后再次运行安装包选中执行修复即可！ 注意：笔者在这里建议，在安装编程环境程序和其他时，安装路径最好不要出现中文！！！也为了保证程序正常稳定的运行，节约时间，最好直接安装到系统盘！！！(安装在其他盘也行，但万一出了啥问题，容易浪费时间去解决不必要的问题) 安装中 安装完成！不做其他设置或更改的话，直接Close即可。 此时，python相关的程序和图标不会出现在系统桌面上，要到开始菜单里面去查看，如下 这是python自带的程序，在之后有需要的地方会一一讲解的。 环境监测安装完成后，要检查本机的python环境是否正常运行 在键盘上按下win+R键,输入cmd，即 回车，打开命令提示符窗口，如下 在里面输入 py 或 python ，回车 出现以上界面，说明python已安装成功并成功添加到系统环境变量 输入 exit() 可退出python命令行，回到正常命令行模式 第一句编程语句——“Hello World!” 用cmd命令行 同理，根据之前的打开cmd的方式，打开并进入到python命令行里 输入 print(&quot;Hello World!&quot;) 回车，即 输出成功！ 注意 print() 是python里输出的方法，有点像Java里的 System.out.println(); 方法 用自带程序Python 3.8 (64-bit)或IDLE (Python 3.8 64-bit)实现 在开始菜单里找到Python 3.8 (64-bit) 界面和cmd是一样的 输入 print(&quot;Hello World!&quot;) 结果也是一样的 在开始菜单里找到IDLE (Python 3.8 64-bit) 这是python 的shell脚本程序 输入 print(&quot;Hello World!&quot;) 结果也是一样的 编写单文件程序 在桌面空白处，右键—新建—文本文档，如图 取个名，叫 test 回车，打开它。输入 print(&quot;Hello World!&quot;) 保存。将文件名后缀改为 .py 此时，Windows弹出警告 点击“是”。 此时图标变为python的文件图标 它是一个可执行文件，如果你双击它，它会立即执行，并很快自动关闭(不是闪退，是瞬间执行了！！！) 为了检测它是否正常输出，我们在cmd里执行它！ 打开cmd(前面已经讲过，这里不在赘述)，切换到这个文件所在的目录，用 cd 命令。(注意：笔者是直接把文件直接建立在桌面) C:\\Users\\Administor&gt;cd C:\\Users\\Administor\\Desktop 在这个目录下，执行python文件，用python命令 C:\\Users\\Administor\\Desktop&gt;python test.py 回车 语句成功输出！！！ 由于笔者匆忙难免有些疏漏，如有不足之处，请指正！ 欢迎关注我们！因为42(是爱),所以精彩！","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}],"tags":[],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Python","slug":"代码学习/Python","permalink":"http://123.56.84.132/public/categories/代码学习/Python/"}]},{"title":"（二）Java变量的概念","slug":"22","date":"2020-01-20T12:50:27.000Z","updated":"2020-03-06T05:38:55.529Z","comments":true,"path":"2020/01/20/22/","link":"","permalink":"http://123.56.84.132/public/2020/01/20/22/","excerpt":"","text":"首先什么是变量？ 变量就是运算过程中需要用到的数据 例如： int a=5;int b=3;int c= a+b; * a、b、c代表了两个整数以及这两个整数的和 今天所讲的内容分别为： 1、变量的声明 2、变量的命名 3、变量的初始化（初始化的两种方式） 1.变量的声明 使用变量前，必须要先声明，不经过声明的变量不能使用 声明：变量名和变量类型 Public static void main（String[] args）{ //编译错误，未声明变量a a=3； } 声明多个变量： Public static void main（String[] args）{ //声明了3 个整型变量，分别赋值为2、3、4 int a=2，b=3，c=4； } 2.变量的命名 规则： 1、可以由数字、字母、”_”、”$”符组成； 2、Java大小写规范，命名时需要注意 3、首字符不能以数字开头 4、不能使用Java保留字，如：int、if、break、for等 5、中文可以作为变量名 在这里介绍一种驼峰命名法： 除了第一个单词，后面的每一个单词第一个字母要大写 按惯例举一个例子： num，classNum，englishClassNum 注：统一规范的写法，有利于不同人的阅读 3.变量的初始化 Java在变量使用前必须初始化，必须给变量赋予特定的值。但在c语言中可以不给值 Public static void main(String[] args){ int a,b=2; int c=a+b;//编译错误，变量a没有初始化 System.out.println( c ); } 初始化的两种方式： 1.声明同时初始化 int a=1； 2.先声明再初始化 int a； a = 1； 代码展示： public class VarDemo { public static void main(String[] args){ //正确 int a=1,b=2,c=3; //可以 以&quot;_&quot;&quot;$&quot;开头 int _a,$abc,abc; //编译错误，不能以数字开头 int 7a; //严格区分大小写，Count！=count int Count=1; System.out.println(count); } }","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://123.56.84.132/public/tags/java/"},{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}]},{"title":"Docker 常用指令","slug":"36","date":"2020-01-19T09:32:00.000Z","updated":"2020-03-06T05:38:55.975Z","comments":true,"path":"2020/01/19/36/","link":"","permalink":"http://123.56.84.132/public/2020/01/19/36/","excerpt":"","text":"一、安装篇 前提条件 Docker 运行在 CentOS 7,Ubuntu 14.04,debian 8等系统版本以上，要求系统为64位、系统内核版本为 3.10 以上。 Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。(此版本只能使用docker.io，新版本docker已经更名为docker-ce) 查看linux内核版本 uname -r 安装 Docker curl -fsSL https://get.docker.com | bash -s docker –mirror Aliyun 查看docker指令帮助 docker help 查看docker版本 docker –version 二、操作篇 启动 Docker 后台服务 systemctl start docker 运行hello-world docker run hello-world 查询远程官方仓库的centos镜像列 docker search centos 拉取官方镜像到本地 docker pull centos:7.0 根据dockerfile 创建一个新镜像（Dockerfile 是一个文本文件，包含了一条条的指令(Instruction)，每条指令都会构建一层） docker build -t imageName:TAG . -f jdkdockerfile 复制文件进某容器中 docker cp test.jar containerID:/usr/local/ 新建并启动一个容器，-t选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。后台运行可使用-d参数，启动后会返回一个唯一id。 docker run -t -i -d imageName:TAG 查询容器的日志 docker logs [container ID or NAMES] 启动已终止容器（状态为existed） docker start [container ID or NAMES] 进入容器内部，操作容器 docker exec -it [containerID] [command] #进容器的command 一般为bash或sh 终止容器 docker stop [containerID] 在容器内部停止容器，等同exist ctrl + d 显示容器 docker ps -a 删除容器 docker rm [containerID] 三、Docker Hub目前 Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 3,016,000 个镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 拉取镜像仓库镜像 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 四、Docker三剑客，后续更新 Docker Compose Docker Machine （docker-ce中不推荐使用) Docker Swarm 五、底层实现 Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。 六、CI/CD 持续集成/部署（GitHub + Drone ） 持续集成(Continuous integration)是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 持续部署（continuous deployment）是通过自动化的构建、测试和部署循环来快速交付高质量的产品。与Jenkins不同的是，基于 Docker 的 CI/CD 每一步都运行在 Docker 镜像中，所以理论上支持所有的编程语言。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://123.56.84.132/public/tags/docker/"},{"name":"linux","slug":"linux","permalink":"http://123.56.84.132/public/tags/linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"替换树莓派raspbian中国源","slug":"35","date":"2020-01-19T03:34:00.000Z","updated":"2020-03-06T05:38:55.945Z","comments":true,"path":"2020/01/19/35/","link":"","permalink":"http://123.56.84.132/public/2020/01/19/35/","excerpt":"","text":"注意本教程仅支持 raspbian 2018-04-19 之后的镜像 1.替换为中科大源 sudo sed -i &#39;s|raspbian.raspberrypi.org|mirrors.ustc.edu.cn/raspbian|g&#39; /etc/apt/sources.list sudo sed -i &#39;s|//archive.raspberrypi.org|//mirrors.ustc.edu.cn/archive.raspberrypi.org|g&#39; /etc/apt/sources.list.d/raspi.list sudo apt update 2.替换为阿里云的源（阿里云没有archive源，这里archive 使用中科大的） sudo sed -i &#39;s|raspbian.raspberrypi.org|mirrors.aliyun.com/raspbian|g&#39; /etc/apt/sources.list sudo sed -i &#39;s|//archive.raspberrypi.org|//mirrors.ustc.edu.cn/archive.raspberrypi.org|g&#39; /etc/apt/sources.list.d/raspi.list sudo apt update","categories":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://123.56.84.132/public/categories/Linux/"}]},{"title":"（一）走进Java的HelloWord","slug":"30","date":"2020-01-19T02:10:00.000Z","updated":"2020-03-06T05:38:55.793Z","comments":true,"path":"2020/01/19/30/","link":"","permalink":"http://123.56.84.132/public/2020/01/19/30/","excerpt":"","text":"1.配置开发环境 学习每一个语言之前，第一件事就是配置好开发环境。 首先安装JDK，我们可以到官网上下载并安装JDK： https://www.oracle.com/technetwork/java/javase/downloads/index.html 因大一下老师要用的可能是JDK8.0，所以有需要的可以私聊我发你。 注：JDK:Java开发工具包 具体配置方法不会的可以去百度，（不会的先百度，是自学的关键） 通过自学配置成功后，我们来通过按住Win+R，输入cmd后： &lt;img src=&quot;https://cdn.jsdelivr.net/gh/xbclub/CDN/wp-content/uploads/2020/01/2189461301.jpg&quot; style=&quot;max-width:100%;&quot;&gt; &lt;br&gt; Java命令： 若你跟以上图片一样，恭喜！你已经成功安装了！ 2.Eclipse编辑器 Eclipse就相当于我们上学期所用的Dev c++，是一个编辑器。 如在家可以到官网进行下载： https://www.eclipse.org/downloads/ 如果你在学校用着内网，那极力推荐来我们42team下载站下载：172.24.4.199 下载站上所有的软件都由我们非常优秀的学长上传，无毒无害，非常的便利！ 解压后打开： 默认装在c盘workspace，要是不想安在c盘，可以在别的盘新建一个文件夹，并在文件夹中新建一个workspace文件夹。安装在workspace下，这点非常重要！ 然后勾选下面的一行英文，点击ok后，我们就会看到以下界面： 在这个界面中，我们点击workbench： 看到这个界面后，我们就成功的触碰到了Java世界的大门。 这里有人可能会问，我英文不好，但这都是英文的，看不懂怎么办。 在这有两个建议: 1.去官网下载中文包 2.克服自己，其实我们要用的地方就那么几个，如果熟练了之后，我们发现其实没有这么难！而且对我们英语有帮助！ 极力推荐第二个建议！! 3.编写第一个程序HelloWord 编写Java首先要创建一个工程（项目）： 在左边空白处右键（也可以在File里） New–Project： 选择Java Project: Next后： 之后第一次使用的可能会弹出一个对话框，直接点击yes即可。 然后我们点击鼠标右键src，建立一个class（类） 之后按照图片步骤完成即可： 那么，最后跟着我敲上两行简单的代码： 注意：因为eclipse是自动编译的，所以我们不需要手动编译。 最后右键Run As -&gt;Java Application 或者点击图标即可运行！ 走到这我们算是跨进了Java世界的大门，可以在Java中遨游了！!","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://123.56.84.132/public/tags/java/"},{"name":"代码","slug":"代码","permalink":"http://123.56.84.132/public/tags/代码/"},{"name":"原创","slug":"原创","permalink":"http://123.56.84.132/public/tags/原创/"}],"keywords":[{"name":"代码学习","slug":"代码学习","permalink":"http://123.56.84.132/public/categories/代码学习/"},{"name":"Java","slug":"代码学习/Java","permalink":"http://123.56.84.132/public/categories/代码学习/Java/"}]},{"title":"《42TEAM的兔子》第五话","slug":"34","date":"2020-01-18T14:08:00.000Z","updated":"2020-03-06T05:38:55.914Z","comments":true,"path":"2020/01/18/34/","link":"","permalink":"http://123.56.84.132/public/2020/01/18/34/","excerpt":"","text":"","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"漫画","slug":"奇思妙想/漫画","permalink":"http://123.56.84.132/public/categories/奇思妙想/漫画/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"漫画","slug":"奇思妙想/漫画","permalink":"http://123.56.84.132/public/categories/奇思妙想/漫画/"}]},{"title":"《42TEAM的兔子》第四话","slug":"33","date":"2020-01-18T14:07:00.000Z","updated":"2020-03-06T05:38:55.882Z","comments":true,"path":"2020/01/18/33/","link":"","permalink":"http://123.56.84.132/public/2020/01/18/33/","excerpt":"","text":"","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"漫画","slug":"奇思妙想/漫画","permalink":"http://123.56.84.132/public/categories/奇思妙想/漫画/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"漫画","slug":"奇思妙想/漫画","permalink":"http://123.56.84.132/public/categories/奇思妙想/漫画/"}]},{"title":"《42TEAM的兔子》第三话","slug":"32","date":"2020-01-18T14:03:00.000Z","updated":"2020-03-06T05:38:55.852Z","comments":true,"path":"2020/01/18/32/","link":"","permalink":"http://123.56.84.132/public/2020/01/18/32/","excerpt":"","text":"","categories":[{"name":"漫画","slug":"漫画","permalink":"http://123.56.84.132/public/categories/漫画/"}],"tags":[],"keywords":[{"name":"漫画","slug":"漫画","permalink":"http://123.56.84.132/public/categories/漫画/"}]},{"title":"《42TEAM的兔子》第二话","slug":"29","date":"2020-01-18T13:54:00.000Z","updated":"2020-03-05T13:19:45.525Z","comments":true,"path":"2020/01/18/29/","link":"","permalink":"http://123.56.84.132/public/2020/01/18/29/","excerpt":"","text":"","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"漫画","slug":"奇思妙想/漫画","permalink":"http://123.56.84.132/public/categories/奇思妙想/漫画/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"漫画","slug":"奇思妙想/漫画","permalink":"http://123.56.84.132/public/categories/奇思妙想/漫画/"}]},{"title":"《42TEAM的兔子》第一话","slug":"11","date":"2020-01-18T13:49:00.000Z","updated":"2020-03-05T13:27:26.560Z","comments":true,"path":"2020/01/18/11/","link":"","permalink":"http://123.56.84.132/public/2020/01/18/11/","excerpt":"","text":"","categories":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"漫画","slug":"奇思妙想/漫画","permalink":"http://123.56.84.132/public/categories/奇思妙想/漫画/"}],"tags":[],"keywords":[{"name":"奇思妙想","slug":"奇思妙想","permalink":"http://123.56.84.132/public/categories/奇思妙想/"},{"name":"漫画","slug":"奇思妙想/漫画","permalink":"http://123.56.84.132/public/categories/奇思妙想/漫画/"}]}]}